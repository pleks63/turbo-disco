// This Pine Script‚Ñ¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// ¬© xwaytheory

//@version=6
indicator(title='HTS - Wstƒôgi', overlay=true)

// HTS Wstƒôgi - Tytu≈Çy
t1 = '1. Poka≈º - HTS Wstƒôgi - G≈Ç√≥wne'
t2 = '2. Poka≈º - HTS Wstƒôgi - Drugi interwa≈Ç czasowy'
t3 = '3. Poka≈º - Koloryzowanie ≈õwiec'
t4 = '4. Poka≈º - Double EMA'
t5 = '5. Poka≈º - Pivot Points'
t6 = '6. Poka≈º - Kijun-Sen'
t7 = '7. Poka≈º - Kijun-Sen - Drugi interwa≈Ç czasowy'
t8 = '8. Poka≈º - VWAP'
t9 = '9. Poka≈º - PO3 - Power of Three'
t10 = '10. Poka≈º - Tabele trend√≥w'
t10A = '10. a) Poka≈º - RSI w Tabeli trend√≥w'

// HTS Wstƒôgi - Grupy
g0 = 'HTS - Wstƒôgi - W≈ÇƒÖcz/Wy≈ÇƒÖcz wska≈∫niki'
g2 = '1. HTS Wstegi - g≈Ç√≥wny interwa≈Ç czasowy - ustawienia'
g3 = '2. HTS Wstƒôgi - Drugi interwa≈Ç czasowy - ustawienia'
g4 = '3. Koloryzowanie ≈õwiec - ustawienia'
g5 = '4. Double EMA - ustawienia'
g6 = '5. Pivot Points - ustawienia'
g7 = '6. Kijun-Sen - ustawienia'
g7a = '7. Kijun-Sen - Drugi interwa≈Ç czasowy - ustawienia'
g8 = '8. VWAP - Volume Weighted Average Price - ustawienia'
g9 = '9. PO3 - Power of Three - ustawienia'
g9a = '9. a) PO3 - Power of Three - kolory ≈õwieczki w g√≥re - ustawienia'
g9b = '9. b) PO3 - Power of Three - kolory ≈õwieczki w d√≥≈Ç - ustawienia'
g9c = '9. c) PO3 - Power of Three - projekcja ≈õwieczki - ustawienia'
g10 = '10. Tabela trend√≥w - ustawienia'
g10a = '10. a) Tabela trend√≥w - interwa≈Çy - ustawienia'

// HTS Wstƒôgi - W≈ÇƒÖcz/Wy≈ÇƒÖcz
show_hts = input.bool(true, title=t1, group=g0)
show_hts2 = input.bool(false, title=t2, group=g0)
show_candle_coloring = input.bool(false, title=t3, group=g0)
show_double_ema = input.bool(false, title=t4, group=g0)
show_pivot_points = input(false, title=t5, group=g0)
show_kijun_sen = input.bool(false, title=t6, group=g0)
show_kijun_sen2 = input.bool(false, title=t7, group=g0)
show_vwap = input.bool(false, title=t8, group=g0)
var show_po3 = input.bool(false, title=t9, group=g0)
show_trend_table = input.bool(true, title=t10, group=g0)
show_rsi_row = input.bool(false, title=t10A, group=g0)

// HTS Wstƒôgi - G≈Ç√≥wne
// Metoda obliczania ≈õrednich kroczƒÖcych dla g≈Ç√≥wnego interwa≈Çu
mamethod = input.string(title='Metoda wstƒôg HTS:', defval='RMA', options=['RMA', 'EMA', 'SMA', 'WMA', 'VWMA'], group=g2)

// Funkcja do obliczania r√≥≈ºnych typ√≥w ≈õrednich kroczƒÖcych
plotmafunc(isrc, ilength, itype) =>
    switch itype
        'RMA' => ta.rma(isrc, ilength)
        'EMA' => ta.ema(isrc, ilength)
        'SMA' => ta.sma(isrc, ilength)
        'WMA' => ta.wma(isrc, ilength)
        'VWMA' => ta.vwma(isrc, ilength)

// D≈Çugo≈õci
lenFast = input.int(33, title='D≈Çugo≈õƒá szybszej wstƒôgi HTS:', group=g2)
lenSlow = input.int(144, title='D≈Çugo≈õƒá wolniejszej wstƒôgi HTS:', group=g2)

// Kolory dla HTS (≈örednie kroczƒÖce)
HTSFastColor = input.color(color.new(#00bbd4, 70), title='Kolor szybszej wstƒôgi HTS:', group=g2)
HTSSlowColor = input.color(color.new(#ff5252, 70), title='Kolor wolniejszej wstƒôgi HTS:', group=g2)

// Obliczenie szybkich i wolnych HTS
HTSFastHigh = plotmafunc(high, lenFast, mamethod)
HTSFastLow = plotmafunc(low, lenFast, mamethod)
HTSSlowHigh = plotmafunc(high, lenSlow, mamethod)
HTSSlowLow = plotmafunc(low, lenSlow, mamethod)

// Kolory t≈Ça wstƒôg
HTSFastFillColor = input.color(color.new(#00bbd4, 95), title='Kolor wype≈Çnienia szybszej wstƒôgi HTS:', group=g2)
HTSSlowFillColor = input.color(color.new(#ff5252, 95), title='Kolor wype≈Çnienia wolniejszej wstƒôgi HTS:', group=g2)

// Definicja trend√≥w na podstawie HTS
isUptrend = HTSFastLow > HTSSlowHigh or HTSFastLow > HTSSlowLow
isDowntrend = HTSFastHigh < HTSSlowLow or HTSFastHigh < HTSSlowHigh

// Rysowanie punkt√≥w przeciƒôcia dla HTS - Kolory
uptrendUpGreenDot = input.color(color.new(#00bbd4, 40), title='Kropka - Przeciƒôcie HTS Wstƒôg w g√≥re - Trend wzrostowy:', group=g2)
downtrendUpGreenDot = input.color(color.new(#4caf50, 100), title='Kropka - Mo≈ºliwe przeciƒôcie HTS Wstƒôg w g√≥re - Trend spadkowy:', group=g2)
uptrendDownRedDot = input.color(color.new(#ff5252, 100), title='Kropka - Mo≈ºliwe przeciƒôcie HTS Wstƒôg w d√≥≈Ç - Trend spadkowy:', group=g2)
downtrendDownRedDot = input.color(color.new(#00bbd4, 40), title='Kropka - Przeciƒôcie HTS Wstƒôg w d√≥≈Ç - Trend spadkowy:', group=g2)

// Rysowanie HTS z mo≈ºliwo≈õciƒÖ zmiany kolor√≥w
plot_HTSFastHigh = plot(show_hts ? HTSFastHigh : na, color=HTSFastColor, linewidth=1, title='HTS szybszej High:')
plot_HTSFastLow = plot(show_hts ? HTSFastLow : na, color=HTSFastColor, linewidth=1, title='HTS szybszej Low:')
plot_HTSSlowHigh = plot(show_hts ? HTSSlowHigh : na, color=HTSSlowColor, linewidth=1, title=' HTS wolnej High:')
plot_HTSSlowLow = plot(show_hts ? HTSSlowLow : na, color=HTSSlowColor, linewidth=1, title='HTS wolnej Low:')

// Wype≈Çnienie t≈Ça miƒôdzy HTS dla lepszej wizualizacji
fill(plot_HTSFastHigh, plot_HTSFastLow, title='Wype≈Çnienie szybszej wstƒôgi HTS:', color=show_hts ? HTSFastFillColor : na)
fill(plot_HTSSlowHigh, plot_HTSSlowLow, title='Wype≈Çnienie wolniejszej wstƒôgi HTS:', color=show_hts ? HTSSlowFillColor : na)

// Rysowanie punkt√≥w przeciƒôcia dla HTS
plot(show_hts and ta.cross(HTSFastLow, HTSSlowHigh) ? HTSSlowHigh : na, color=ta.crossover(HTSFastLow, HTSSlowHigh) ? uptrendUpGreenDot : uptrendDownRedDot, style=plot.style_circles, linewidth=3, title='Przeciƒôcie szybszej Low z wolniejszƒÖ Hig:')
plot(show_hts and ta.cross(HTSFastHigh, HTSSlowLow) ? HTSSlowLow : na, color=ta.crossover(HTSFastHigh, HTSSlowLow) ? downtrendUpGreenDot : downtrendDownRedDot, style=plot.style_circles, linewidth=3, title='Przeciƒôcie szybszej High z wolniejszƒÖ Low:')

// HTS Wstƒôgi - Drugi interwa≈Ç czasowy
// Ustawienia dla drugiego interwa≈Çu
tf2 = input.timeframe(title='HTS - Drugi interwa≈Ç czasowy:', defval='60', group=g3)
mamethod2 = input.string(title='Metoda wstƒôg HTS - Drugi interwa≈Ç czasowy:', defval='RMA', options=['RMA', 'EMA', 'SMA', 'WMA', 'VWMA'], group=g3)
shortval2 = input.int(33, title='D≈Çugo≈õƒá szybszej wstƒôgi HTS - Drugi interwa≈Ç czasowy:', group=g3)
longval2 = input.int(144, title='D≈Çugo≈õƒá wolniejszej wstƒôgi HTS - Drugi interwa≈Ç czasowy:', group=g3)
shortcol2 = input.color(color.new(#00bbd4, 80), title='Kolor szybszej wstƒôgi HTS - Drugi interwa≈Ç czasowy:', group=g3)
longcol2 = input.color(color.new(#ff5252, 80), title='Kolor wolniejszej wstƒôgi HTS - Drugi interwa≈Ç czasowy:', group=g3)

// Rysowanie ≈õrednich kroczƒÖcych dla drugiego interwa≈Çu
plotsh2 = plot(show_hts2 ? request.security(syminfo.tickerid, tf2, plotmafunc(high, shortval2, mamethod2), gaps=barmerge.gaps_on) : na, color=shortcol2, linewidth=1, title='HTS Szybsza High - Drugi interwa≈Ç czasowy:')
plotsl2 = plot(show_hts2 ? request.security(syminfo.tickerid, tf2, plotmafunc(low, shortval2, mamethod2), gaps=barmerge.gaps_on) : na, color=shortcol2, linewidth=1, title='HTS Szybsza Low - Drugi interwa≈Ç czasowy:')
plotlh2 = plot(show_hts2 ? request.security(syminfo.tickerid, tf2, plotmafunc(high, longval2, mamethod2), gaps=barmerge.gaps_on) : na, color=longcol2, linewidth=1, title='HTS Wolna High - Drugi interwa≈Ç czasowy:')
plotll2 = plot(show_hts2 ? request.security(syminfo.tickerid, tf2, plotmafunc(low, longval2, mamethod2), gaps=barmerge.gaps_on) : na, color=longcol2, linewidth=1, title='HTS Wolna Low - Drugi interwa≈Ç czasowy:')

// HTS Wstƒôgi - Koloryzowanie ≈õwiec
// Dodanie mo≈ºliwo≈õci wyboru interwa≈Çu dla koloryzacji ≈õwiec
candle_coloring_tf = input.timeframe("", title="Interwa≈Ç dla koloryzacji ≈õwiec:", group=g4)

// Pobranie warto≈õci HTS z wybranego interwa≈Çu
h1_hts_high = request.security(syminfo.tickerid, candle_coloring_tf, HTSFastHigh, lookahead=barmerge.lookahead_on)
h1_hts_low = request.security(syminfo.tickerid, candle_coloring_tf, HTSFastLow, lookahead=barmerge.lookahead_on)

// Kolory dla ≈õwiec - ustawienia u≈ºytkownika
candle_up_color = input.color(#089981, title="Kolor ≈õwiec nad HTS H1:", group=g4)
candle_down_color = input.color(#f23645, title="Kolor ≈õwiec pod HTS H1:", group=g4)
candle_neutral_color = input.color(#b2b5be, title="Kolor ≈õwiec wewnƒÖtrz HTS H1:", group=g4)

// Funkcja do okre≈õlania koloru ≈õwiecy na podstawie HTS H1
f_getCandleColor() =>
    if show_candle_coloring
        if close > h1_hts_high
            candle_up_color
        else if close < h1_hts_low
            candle_down_color
        else
            candle_neutral_color
    else
        na

// Zastosowanie kolor√≥w do ≈õwiec na wykresie
candle_color = f_getCandleColor()
plotcandle(open, high, low, close, color=candle_color, wickcolor=candle_color, bordercolor=candle_color)


// HTS Wstƒôgi - Double EMA
// Ustawienia dla Double EMA
len1 = input.int(9, minval=1, title="D≈Çugo≈õƒá pierwszej EMA", group=g5)
len2 = input.int(21, minval=1, title="D≈Çugo≈õƒá drugiej EMA", group=g5)
ema1_color = input.color(color.blue, title="Kolor pierwszej EMA", group=g5)
ema2_color = input.color(color.red, title="Kolor drugiej EMA", group=g5)

// Obliczenie EMA
ema1 = ta.ema(close, len1)
ema2 = ta.ema(close, len2)

// Rysowanie EMA na wykresie
plot(show_double_ema ? ema1 : na, title="EMA 1", color=ema1_color, linewidth=1)
plot(show_double_ema ? ema2 : na, title="EMA 2", color=ema2_color, linewidth=1)

// HTS Wstƒôgi - Pivot Points
// Ustawienia dla Pivot Points
AUTO = 'Auto'
DAILY = 'Daily'
WEEKLY = 'Weekly'
MONTHLY = 'Monthly'
QUARTERLY = 'Quarterly'
YEARLY = 'Yearly'
BIYEARLY = 'Biyearly'
TRIYEARLY = 'Triyearly'
QUINQUENNIALLY = 'Quinquennially'
DECENNIALLY = 'Decennially'

TRADITIONAL = 'Traditional'
FIBONACCI = 'Fibonacci'
WOODIE = 'Woodie'
CLASSIC = 'Classic'
DEMARK = 'DM'
CAMARILLA = 'Camarilla'

kind = input.string('Traditional', title='Typ Pivot Points:', options=[TRADITIONAL, FIBONACCI, WOODIE, CLASSIC, DEMARK, CAMARILLA], group=g6)
look_back = input.int(1, title='Ilo≈õƒá Pivot Points w ty≈Ç:', minval=1, maxval=5000)
pivot_time_frame = input.string(DAILY, title='Interwa≈Ç czasowy dla Pivot Points:', options=[AUTO, DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY, BIYEARLY, TRIYEARLY, QUINQUENNIALLY, DECENNIALLY])
is_daily_based = input.bool(true, title='U≈ºyj warto≈õci dziennych dla Pivot Points:', tooltip='Gdy ta opcja jest odznaczona, punkty osiowe bƒôdƒÖ u≈ºywa≈Çy danych ≈õr√≥ddziennych podczas obliczania na wykresach ≈õr√≥ddziennych. Je≈õli na wykresie wy≈õwietlane sƒÖ godziny rozszerzone, zostanƒÖ one uwzglƒôdnione podczas obliczania poziom√≥w osiowych. Je≈õli ≈õr√≥ddzienne warto≈õci OHLC r√≥≈ºniƒÖ siƒô od warto≈õci dziennych (normalne w przypadku akcji), poziomy osiowe r√≥wnie≈º bƒôdƒÖ siƒô r√≥≈ºniƒá.')
show_labels = input.bool(true, title='Poka≈º oznaczenia Pivot Points:', group=g6)
show_prices = input.bool(true, title='Poka≈º warto≈õci Pivot Points:', group=g6)
position_labels = input.string('Prawa', 'Po kt√≥rej stronie oznaczenia dla Pivot Points:', options=['Lewa', 'Prawa'], group=g6)
line_width = input.int(1, title='Grubo≈õƒá lini Pivot Points:', minval=1, maxval=100, group=g6)

var DEF_COLOR = #808080
var DEF_COLOR_P = #b2b5be
var DEF_COLOR_S = #4caf50
var DEF_COLOR_R = #f05350
var arr_time = array.new_int()
var p = array.new_float()
p_color = input.color(DEF_COLOR_P, 'P‚Äè  ‚Äè  ‚Äè', inline='P', group=g6)
p_show = input.bool(true, '', inline='P', group=g6)
var r1 = array.new_float()
var s1 = array.new_float()
s1_color = input.color(DEF_COLOR_S, 'S1', inline='S1/R1', group=g6)
s1_show = input.bool(true, '', inline='S1/R1', group=g6)
r1_color = input.color(DEF_COLOR_R, '‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚ÄèR1', inline='S1/R1', group=g6)
r1_show = input.bool(true, '', inline='S1/R1', group=g6)
var r2 = array.new_float()
var s2 = array.new_float()
s2_color = input.color(DEF_COLOR_S, 'S2', inline='S2/R2', group=g6)
s2_show = input.bool(true, '', inline='S2/R2', group=g6)
r2_color = input.color(DEF_COLOR_R, '‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚ÄèR2', inline='S2/R2', group=g6)
r2_show = input.bool(true, '', inline='S2/R2', group=g6)
var r3 = array.new_float()
var s3 = array.new_float()
s3_color = input.color(DEF_COLOR_S, 'S3', inline='S3/R3', group=g6)
s3_show = input.bool(true, '', inline='S3/R3', group=g6)
r3_color = input.color(DEF_COLOR_R, '‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚ÄèR3', inline='S3/R3', group=g6)
r3_show = input.bool(true, '', inline='S3/R3', group=g6)
var r4 = array.new_float()
var s4 = array.new_float()
s4_color = input.color(DEF_COLOR_S, 'S4', inline='S4/R4', group=g6)
s4_show = input.bool(false, '', inline='S4/R4', group=g6)
r4_color = input.color(DEF_COLOR_R, '‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚ÄèR4', inline='S4/R4', group=g6)
r4_show = input.bool(false, '', inline='S4/R4', group=g6)
var r5 = array.new_float()
var s5 = array.new_float()
s5_color = input.color(DEF_COLOR_S, 'S5', inline='S5/R5', group=g6)
s5_show = input.bool(false, '', inline='S5/R5', group=g6)
r5_color = input.color(DEF_COLOR_R, '‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚Äè  ‚ÄèR5', inline='S5/R5', group=g6)
r5_show = input.bool(false, '', inline='S5/R5', group=g6)

pivotX_open = float(na)
pivotX_open := nz(pivotX_open[1], open)
pivotX_high = float(na)
pivotX_high := nz(pivotX_high[1], high)
pivotX_low = float(na)
pivotX_low := nz(pivotX_low[1], low)
pivotX_prev_open = float(na)
pivotX_prev_open := nz(pivotX_prev_open[1])
pivotX_prev_high = float(na)
pivotX_prev_high := nz(pivotX_prev_high[1])
pivotX_prev_low = float(na)
pivotX_prev_low := nz(pivotX_prev_low[1])
pivotX_prev_close = float(na)
pivotX_prev_close := nz(pivotX_prev_close[1])

get_pivot_resolution() =>
    resolution = 'M'
    if pivot_time_frame == AUTO
        if timeframe.isintraday
            resolution := timeframe.multiplier <= 15 ? 'D' : 'W'
        else if timeframe.isweekly or timeframe.ismonthly
            resolution := '12M'
    else if pivot_time_frame == DAILY
        resolution := 'D'
    else if pivot_time_frame == WEEKLY
        resolution := 'W'
    else if pivot_time_frame == MONTHLY
        resolution := 'M'
    else if pivot_time_frame == QUARTERLY
        resolution := '3M'
    else if pivot_time_frame == YEARLY or pivot_time_frame == BIYEARLY or pivot_time_frame == TRIYEARLY or pivot_time_frame == QUINQUENNIALLY or pivot_time_frame == DECENNIALLY
        resolution := '12M'
    resolution

var lines = array.new_line()
var labels = array.new_label()

draw_line(i, pivot, col) =>
    if array.size(arr_time) > 1
        array.push(lines, line.new(array.get(arr_time, i), array.get(pivot, i), array.get(arr_time, i + 1), array.get(pivot, i), color=col, xloc=xloc.bar_time, width=line_width))

draw_label(i, y, txt, txt_color) =>
    if (show_labels or show_prices) and not na(y)
        display_text = (show_labels ? txt : '') + (show_prices ? str.format(' ({0})', math.round_to_mintick(y)) : '')
        label_style = position_labels == 'Prawa' ? label.style_label_left : label.style_label_right
        x = position_labels == 'Lewa' ? array.get(arr_time, i) : array.get(arr_time, i + 1)
        array.push(labels, label.new(x=x, y=y, text=display_text, textcolor=txt_color, style=label_style, color=#00000000, xloc=xloc.bar_time))

traditional() =>
    pivotX_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_prev_close) / 3
    array.push(p, pivotX_Median)
    array.push(r1, pivotX_Median * 2 - pivotX_prev_low)
    array.push(s1, pivotX_Median * 2 - pivotX_prev_high)
    array.push(r2, pivotX_Median + 1 * (pivotX_prev_high - pivotX_prev_low))
    array.push(s2, pivotX_Median - 1 * (pivotX_prev_high - pivotX_prev_low))
    array.push(r3, pivotX_Median * 2 + pivotX_prev_high - 2 * pivotX_prev_low)
    array.push(s3, pivotX_Median * 2 - (2 * pivotX_prev_high - pivotX_prev_low))
    array.push(r4, pivotX_Median * 3 + pivotX_prev_high - 3 * pivotX_prev_low)
    array.push(s4, pivotX_Median * 3 - (3 * pivotX_prev_high - pivotX_prev_low))
    array.push(r5, pivotX_Median * 4 + pivotX_prev_high - 4 * pivotX_prev_low)
    array.push(s5, pivotX_Median * 4 - (4 * pivotX_prev_high - pivotX_prev_low))

fibonacci() =>
    pivotX_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_prev_close) / 3
    pivot_range = pivotX_prev_high - pivotX_prev_low
    array.push(p, pivotX_Median)
    array.push(r1, pivotX_Median + 0.382 * pivot_range)
    array.push(s1, pivotX_Median - 0.382 * pivot_range)
    array.push(r2, pivotX_Median + 0.618 * pivot_range)
    array.push(s2, pivotX_Median - 0.618 * pivot_range)
    array.push(r3, pivotX_Median + 1 * pivot_range)
    array.push(s3, pivotX_Median - 1 * pivot_range)

woodie() =>
    pivotX_Woodie_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_open * 2) / 4
    pivot_range = pivotX_prev_high - pivotX_prev_low
    array.push(p, pivotX_Woodie_Median)
    array.push(r1, pivotX_Woodie_Median * 2 - pivotX_prev_low)
    array.push(s1, pivotX_Woodie_Median * 2 - pivotX_prev_high)
    array.push(r2, pivotX_Woodie_Median + 1 * pivot_range)
    array.push(s2, pivotX_Woodie_Median - 1 * pivot_range)
    pivot_point_r3 = pivotX_prev_high + 2 * (pivotX_Woodie_Median - pivotX_prev_low)
    pivot_point_s3 = pivotX_prev_low - 2 * (pivotX_prev_high - pivotX_Woodie_Median)
    array.push(r3, pivot_point_r3)
    array.push(s3, pivot_point_s3)
    array.push(r4, pivot_point_r3 + pivot_range)
    array.push(s4, pivot_point_s3 - pivot_range)

classic() =>
    pivotX_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_prev_close) / 3
    pivot_range = pivotX_prev_high - pivotX_prev_low
    array.push(p, pivotX_Median)
    array.push(r1, pivotX_Median * 2 - pivotX_prev_low)
    array.push(s1, pivotX_Median * 2 - pivotX_prev_high)
    array.push(r2, pivotX_Median + 1 * pivot_range)
    array.push(s2, pivotX_Median - 1 * pivot_range)
    array.push(r3, pivotX_Median + 2 * pivot_range)
    array.push(s3, pivotX_Median - 2 * pivot_range)
    array.push(r4, pivotX_Median + 3 * pivot_range)
    array.push(s4, pivotX_Median - 3 * pivot_range)

demark() =>
    pivotX_Demark_X = pivotX_prev_high + pivotX_prev_low * 2 + pivotX_prev_close
    if pivotX_prev_close == pivotX_prev_open
        pivotX_Demark_X := pivotX_prev_high + pivotX_prev_low + pivotX_prev_close * 2
    if pivotX_prev_close > pivotX_prev_open
        pivotX_Demark_X := pivotX_prev_high * 2 + pivotX_prev_low + pivotX_prev_close
    array.push(p, pivotX_Demark_X / 4)
    array.push(r1, pivotX_Demark_X / 2 - pivotX_prev_low)
    array.push(s1, pivotX_Demark_X / 2 - pivotX_prev_high)

camarilla() =>
    pivotX_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_prev_close) / 3
    pivot_range = pivotX_prev_high - pivotX_prev_low
    array.push(p, pivotX_Median)
    array.push(r1, pivotX_prev_close + pivot_range * 1.1 / 12.0)
    array.push(s1, pivotX_prev_close - pivot_range * 1.1 / 12.0)
    array.push(r2, pivotX_prev_close + pivot_range * 1.1 / 6.0)
    array.push(s2, pivotX_prev_close - pivot_range * 1.1 / 6.0)
    array.push(r3, pivotX_prev_close + pivot_range * 1.1 / 4.0)
    array.push(s3, pivotX_prev_close - pivot_range * 1.1 / 4.0)
    array.push(r4, pivotX_prev_close + pivot_range * 1.1 / 2.0)
    array.push(s4, pivotX_prev_close - pivot_range * 1.1 / 2.0)
    r5_val = pivotX_prev_high / pivotX_prev_low * pivotX_prev_close
    array.push(r5, r5_val)
    array.push(s5, 2 * pivotX_prev_close - r5_val)

calc_pivot() =>
    if kind == TRADITIONAL
        traditional()
    else if kind == FIBONACCI
        fibonacci()
    else if kind == WOODIE
        woodie()
    else if kind == CLASSIC
        classic()
    else if kind == DEMARK
        demark()
    else if kind == CAMARILLA
        camarilla()

resolution = get_pivot_resolution()

SIMPLE_DIVISOR = -1
custom_years_divisor = switch pivot_time_frame
    BIYEARLY => 2
    TRIYEARLY => 3
    QUINQUENNIALLY => 5
    DECENNIALLY => 10
    => SIMPLE_DIVISOR

calc_high(prev, curr) =>
    if na(prev) or na(curr)
        nz(prev, nz(curr, na))
    else
        math.max(prev, curr)

calc_low(prev, curr) =>
    if not na(prev) and not na(curr)
        math.min(prev, curr)
    else
        nz(prev, nz(curr, na))

calc_OHLC_for_pivot(custom_years_divisor) =>
    if custom_years_divisor == SIMPLE_DIVISOR
        [open, high, low, close, open[1], high[1], low[1], close[1], time[1], time_close]
    else
        var prev_sec_open = float(na)
        var prev_sec_high = float(na)
        var prev_sec_low = float(na)
        var prev_sec_close = float(na)
        var prev_sec_time = int(na)
        var curr_sec_open = float(na)
        var curr_sec_high = float(na)
        var curr_sec_low = float(na)
        var curr_sec_close = float(na)
        if year(time_close) % custom_years_divisor == 0
            curr_sec_open := open
            curr_sec_high := high
            curr_sec_low := low
            curr_sec_close := close
            prev_sec_high := high[1]
            prev_sec_low := low[1]
            prev_sec_close := close[1]
            prev_sec_time := time[1]
            for i = 2 to custom_years_divisor by 1
                prev_sec_open := nz(open[i], prev_sec_open)
                prev_sec_high := calc_high(prev_sec_high, high[i])
                prev_sec_low := calc_low(prev_sec_low, low[i])
                prev_sec_time := nz(time[i], prev_sec_time)
        [curr_sec_open, curr_sec_high, curr_sec_low, curr_sec_close, prev_sec_open, prev_sec_high, prev_sec_low, prev_sec_close, prev_sec_time, time_close]

[sec_open, sec_high, sec_low, sec_close, prev_sec_open, prev_sec_high, prev_sec_low, prev_sec_close, prev_sec_time, sec_time] = request.security(syminfo.tickerid, resolution, calc_OHLC_for_pivot(custom_years_divisor), lookahead=barmerge.lookahead_on)
sec_open_gaps_on = request.security(syminfo.tickerid, resolution, open, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)

// Global variables for ta.change() results
time_change = ta.change(time(resolution)) != 0
sec_open_change = ta.change(sec_open) != 0

is_change_years = custom_years_divisor > 0 and time_change and year(time_close) % custom_years_divisor == 0

var is_change = false
var uses_current_bar = timeframe.isintraday and kind == WOODIE
var change_time = int(na)
is_time_change = time_change and custom_years_divisor == SIMPLE_DIVISOR or is_change_years
if is_time_change
    change_time := time

var start_time = time
var was_last_premarket = false
var start_calculate_in_premarket = false

is_last_premarket = barstate.islast and session.ispremarket and time_close > sec_time and not was_last_premarket

if is_last_premarket
    was_last_premarket := true
    start_calculate_in_premarket := true
if session.ismarket
    was_last_premarket := false

without_time_change = barstate.islast and array.size(arr_time) == 0
is_can_calc_pivot = not uses_current_bar and is_time_change and session.ismarket or sec_open_change and not start_calculate_in_premarket or is_last_premarket or uses_current_bar and not na(sec_open_gaps_on) or without_time_change
enough_bars_for_calculate = prev_sec_time >= start_time or is_daily_based

if is_can_calc_pivot and enough_bars_for_calculate
    if array.size(arr_time) == 0 and is_daily_based
        pivotX_prev_open := prev_sec_open[1]
        pivotX_prev_high := prev_sec_high[1]
        pivotX_prev_low := prev_sec_low[1]
        pivotX_prev_close := prev_sec_close[1]
        pivotX_open := sec_open[1]
        pivotX_high := sec_high[1]
        pivotX_low := sec_low[1]
        array.push(arr_time, start_time)
        calc_pivot()

    if is_daily_based
        if is_last_premarket
            pivotX_prev_open := sec_open
            pivotX_prev_high := sec_high
            pivotX_prev_low := sec_low
            pivotX_prev_close := sec_close
            pivotX_open := open
            pivotX_high := high
            pivotX_low := low
        else
            pivotX_prev_open := prev_sec_open
            pivotX_prev_high := prev_sec_high
            pivotX_prev_low := prev_sec_low
            pivotX_prev_close := prev_sec_close
            pivotX_open := sec_open
            pivotX_high := sec_high
            pivotX_low := sec_low
    else
        pivotX_prev_high := pivotX_high
        pivotX_prev_low := pivotX_low
        pivotX_prev_open := pivotX_open
        pivotX_prev_close := close[1]
        pivotX_open := open
        pivotX_high := high
        pivotX_low := low

    if barstate.islast and not is_change and array.size(arr_time) > 0 and not without_time_change
        array.set(arr_time, array.size(arr_time) - 1, change_time)
    else if without_time_change
        array.push(arr_time, start_time)
    else
        array.push(arr_time, nz(change_time, time))

    calc_pivot()

    if array.size(arr_time) > look_back
        if array.size(arr_time) > 0
            array.shift(arr_time)
        if array.size(p) > 0 and p_show and show_pivot_points
            array.shift(p)
        if array.size(r1) > 0 and r1_show and show_pivot_points
            array.shift(r1)
        if array.size(s1) > 0 and s1_show and show_pivot_points
            array.shift(s1)
        if array.size(r2) > 0 and r2_show and show_pivot_points
            array.shift(r2)
        if array.size(s2) > 0 and s2_show and show_pivot_points
            array.shift(s2)
        if array.size(r3) > 0 and r3_show and show_pivot_points
            array.shift(r3)
        if array.size(s3) > 0 and s3_show and show_pivot_points
            array.shift(s3)
        if array.size(r4) > 0 and r4_show and show_pivot_points
            array.shift(r4)
        if array.size(s4) > 0 and s4_show and show_pivot_points
            array.shift(s4)
        if array.size(r5) > 0 and r5_show and show_pivot_points
            array.shift(r5)
        if array.size(s5) > 0 and s5_show and show_pivot_points
            array.shift(s5)
    is_change := true
else if not is_daily_based
    pivotX_high := math.max(pivotX_high, high)
    pivotX_low := math.min(pivotX_low, low)

if barstate.islast and not is_daily_based and array.size(arr_time) == 0
    runtime.error('Not enough intraday data to calculate Pivot Points.')

if barstate.islast and array.size(arr_time) > 0 and is_change
    is_change := false
    if custom_years_divisor > 0
        last_pivot_time = array.get(arr_time, array.size(arr_time) - 1)
        pivot_timeframe = str.tostring(12 * custom_years_divisor) + 'M'
        estimate_pivot_time = last_pivot_time + timeframe.in_seconds(pivot_timeframe) * 1000
        array.push(arr_time, estimate_pivot_time)
    else
        array.push(arr_time, time_close(resolution))

    for i = 0 to array.size(lines) - 1 by 1
        if array.size(lines) > 0
            line.delete(array.shift(lines))
        if array.size(labels) > 0
            label.delete(array.shift(labels))

    for i = 0 to array.size(arr_time) - 2 by 1
        if array.size(p) > 0 and p_show and show_pivot_points
            draw_line(i, p, p_color)
            draw_label(i, array.get(p, i), 'P', p_color)
        if array.size(r1) > 0 and r1_show and show_pivot_points
            draw_line(i, r1, r1_color)
            draw_label(i, array.get(r1, i), 'R1', r1_color)
        if array.size(s1) > 0 and s1_show and show_pivot_points
            draw_line(i, s1, s1_color)
            draw_label(i, array.get(s1, i), 'S1', s1_color)
        if array.size(r2) > 0 and r2_show and show_pivot_points
            draw_line(i, r2, r2_color)
            draw_label(i, array.get(r2, i), 'R2', r2_color)
        if array.size(s2) > 0 and s2_show and show_pivot_points
            draw_line(i, s2, s2_color)
            draw_label(i, array.get(s2, i), 'S2', s2_color)
        if array.size(r3) > 0 and r3_show and show_pivot_points
            draw_line(i, r3, r3_color)
            draw_label(i, array.get(r3, i), 'R3', r3_color)
        if array.size(s3) > 0 and s3_show and show_pivot_points
            draw_line(i, s3, s3_color)
            draw_label(i, array.get(s3, i), 'S3', s3_color)
        if array.size(r4) > 0 and r4_show and show_pivot_points
            draw_line(i, r4, r4_color)
            draw_label(i, array.get(r4, i), 'R4', r4_color)
        if array.size(s4) > 0 and s4_show and show_pivot_points
            draw_line(i, s4, s4_color)
            draw_label(i, array.get(s4, i), 'S4', s4_color)
        if array.size(r5) > 0 and r5_show and show_pivot_points
            draw_line(i, r5, r5_color)
            draw_label(i, array.get(r5, i), 'R5', r5_color)
        if array.size(s5) > 0 and s5_show and show_pivot_points
            draw_line(i, s5, s5_color)
            draw_label(i, array.get(s5, i), 'S5', s5_color)

// Wyodrƒôbnienie wywo≈Ça≈Ñ ta.cross do osobnych zmiennych
cross_pp = ta.cross(close, array.size(p) > 0 ? array.get(p, array.size(p) - 1) : na)
cross_s1 = ta.cross(close, array.size(s1) > 0 ? array.get(s1, array.size(s1) - 1) : na)
cross_s2 = ta.cross(close, array.size(s2) > 0 ? array.get(s2, array.size(s2) - 1) : na)
cross_s3 = ta.cross(close, array.size(s3) > 0 ? array.get(s3, array.size(s3) - 1) : na)
cross_s4 = ta.cross(close, array.size(s4) > 0 ? array.get(s4, array.size(s4) - 1) : na)
cross_s5 = ta.cross(close, array.size(s5) > 0 ? array.get(s5, array.size(s5) - 1) : na)
cross_r1 = ta.cross(close, array.size(r1) > 0 ? array.get(r1, array.size(r1) - 1) : na)
cross_r2 = ta.cross(close, array.size(r2) > 0 ? array.get(r2, array.size(r2) - 1) : na)
cross_r3 = ta.cross(close, array.size(r3) > 0 ? array.get(r3, array.size(r3) - 1) : na)
cross_r4 = ta.cross(close, array.size(r4) > 0 ? array.get(r4, array.size(r4) - 1) : na)
cross_r5 = ta.cross(close, array.size(r5) > 0 ? array.get(r5, array.size(r5) - 1) : na)

// Warunki alarmowe dla Pivot Points
alert_pp = array.size(p) > 0 and cross_pp
alert_s1 = array.size(s1) > 0 and cross_s1
alert_s2 = array.size(s2) > 0 and cross_s2
alert_s3 = array.size(s3) > 0 and cross_s3
alert_s4 = array.size(s4) > 0 and cross_s4
alert_s5 = array.size(s5) > 0 and cross_s5
alert_r1 = array.size(r1) > 0 and cross_r1
alert_r2 = array.size(r2) > 0 and cross_r2
alert_r3 = array.size(r3) > 0 and cross_r3
alert_r4 = array.size(r4) > 0 and cross_r4
alert_r5 = array.size(r5) > 0 and cross_r5

// HTS Wstƒôgi - Kijun-Sen
// Wykres linii Kijun-sen
basePeriods = input.int(26, title='Okres Kijun-Sen:', group=g7)
kijun_color = input.color(color.new(#ffff00, 60), 'Kolor Kijun-Sen:', group=g7)

donchian(len) => math.avg(ta.lowest(len), ta.highest(len))
baseLine = donchian(basePeriods)

plot(show_kijun_sen ? baseLine : na, 'Linia Kijun-Sen:', kijun_color, 1)

// HTS Wstƒôgi - Kijun-Sen - Drugi interwa≈Ç czasowy
// Ustawienia dla drugiego Kijun-Sen
kijun2_tf = input.timeframe(title='Interwa≈Ç czasowy:', defval='60', group=g7a)
kijun2_basePeriods = input.int(26, title='Okres Kijun-Sen - Drugi interwa≈Ç czasowy:', group=g7a)
kijun2_color = input.color(color.new(#ffff00, 60), 'Kolor Kijun-Sen - Drugi interwa≈Ç czasowy:', group=g7a)

kijun2_donchian(len) => math.avg(ta.lowest(len), ta.highest(len))
kijun2_baseLine = request.security(syminfo.tickerid, kijun2_tf, kijun2_donchian(kijun2_basePeriods), gaps=barmerge.gaps_on)

plot(show_kijun_sen2 ? kijun2_baseLine : na, 'Linia Kijun-Sen - Drugi interwa≈Ç:', kijun2_color, 1)

// HTS Wstƒôgi - VWAP - Volume Weighted Average Price
// ustawienia VWAP
vwap_tf = input.timeframe(title="Interwa≈Ç czasowy VWAP:", defval="", group=g8)
hideonDWM = input.bool(false, title="Ukryj VWAP na interwa≈Çach D/W/M", group=g8)
anchor = input.string("Session", title="Okres bazowy:", options=["Session", "Week", "Month", "Quarter", "Year", "Decade", "Century", "Earnings", "Dividends", "Splits"], group=g8)
src_vwap = input(hlc3, title="≈πr√≥d≈Ço VWAP:", group=g8)
offset_vwap = input.int(0, title="Odsadzenie VWAP:", minval=0, group=g8)
vwap_color = input.color(#2962FF, title="Kolor VWAP:", group=g8)
vwap_linewidth = input.int(1, title="Grubo≈õƒá linii VWAP:", minval=1, maxval=5, group=g8)

// Obliczanie VWAP dla wybranego interwa≈Çu czasowego
var float vwapValue = na
if show_vwap and not (hideonDWM and timeframe.isdwm)
    isNewPeriod = switch anchor
        "Earnings"  => not na(request.earnings(syminfo.tickerid))
        "Dividends" => not na(request.dividends(syminfo.tickerid))
        "Splits"    => not na(request.splits(syminfo.tickerid, field="ratio"))  // Dodano field="ratio"
        "Session"   => timeframe.change("D")
        "Week"      => timeframe.change("W")
        "Month"     => timeframe.change("M")
        "Quarter"   => timeframe.change("3M")
        "Year"      => timeframe.change("12M")
        "Decade"    => timeframe.change("12M") and year % 10 == 0
        "Century"   => timeframe.change("12M") and year % 100 == 0
        => false

    // Pobieranie danych VWAP z wybranego interwa≈Çu czasowego
    [_vwap, _, _] = request.security(syminfo.tickerid, vwap_tf, ta.vwap(src_vwap, isNewPeriod, 1), gaps=barmerge.gaps_on)
    vwapValue := _vwap

// Rysowanie VWAP na wykresie
plot(show_vwap ? vwapValue : na, title="VWAP", color=vwap_color, offset=offset_vwap, linewidth=vwap_linewidth)

// HTS Wstƒôgi - PO3 - Power of Three
// Ustawienia dla PO3
var tf = input.timeframe("60", "Interwa≈Ç:", inline="tf", group=g9)
var tf_auto = input.bool(false, "Ustal automatycznie", inline="tf", group=g9)
var tf_2lvs = input.bool(false, "Dwu poziomowy", inline="tf", group=g9)
var num = input.int(1, "Liczba HTF ≈õwieczek:", minval=1, group=g9)
var offset = input.int(10, "Odsadzenie:", group=g9)
var size = input.string("Medium", "Wielko≈õƒá:", options=["Small", "Medium", "Large"], group=g9)
var type = input.string("Candles", "Typ:", options=["Candles", "Heikin Ashi"], group=g9)
var margin = input.int(1, "Odstep miƒôdzy:", minval=1, group=g9)
var htf_data = input.string("Is Weekly", "U≈ºyj HTF danych do wygenerowania ≈õwieczki:", options=["Is Weekly", "Always", "Never"], group=g9)

// Inputs for Candle Colors
var up_col = input.color(color.new(#089981, 0), "Body", inline="Candles", group=g9a)
var up_col_wick = input.color(color.new(#089981, 0), "Wick", inline="Candles", group=g9a)
var up_col_border = input.color(color.new(#089981, 0), "Border", inline="Candles", group=g9a)
var down_col = input.color(color.new(#f23645, 0), "Body", inline="Candles", group=g9b)
var down_col_wick = input.color(color.new(#f23645, 0), "Wick", inline="Candles", group=g9b)
var down_col_border = input.color(color.new(#f23645, 0), "Border", inline="Candles", group=g9b)

// Inputs for Projections
var o_col = input.color(color.new(#b2b5be, 10), "", inline="o", group=g9c)
var o_style = input.string("Dotted", "", options=["Solid", "Dotted", "Dashed"], inline="o", group=g9c)
var o_width = input.int(1, "Grubo≈õƒá lini:", minval=1, inline="o", group=g9c)
var o_enabled = input.bool(true, "Open", inline="o", group=g9c)
var hl_col = input.color(color.new(#b2b5be, 10), "", inline="hl", group=g9c)
var hl_style = input.string("Dotted", "", options=["Solid", "Dotted", "Dashed"], inline="hl", group=g9c)
var hl_width = input.int(1, "Grubo≈õƒá lini:", minval=1, inline="hl", group=g9c)
var hl_enabled = input.bool(true, "High/Low", inline="hl", group=g9c)
var ohlc_col = input.color(color.new(#b2b5be, 10), "", inline="ohlc", group=g9c)
var ohlc_size = input.string("Auto", "", options=["Auto", "Tiny", "Small", "Normal", "Large", "Huge"], inline="ohlc", group=g9c)
var ohlc_enabled = input.bool(true, "OHLC Prices", inline="ohlc", group=g9c)

// New Inputs for Label Font Size and Color
var font_size = input.string("Small", "Wielko≈õc czcionki:", options=["Tiny", "Small", "Normal", "Large", "Huge"], group=g9c)
var font_color = input.color(#b2b5be, "Kolor czcionki:", group=g9c)

// Candle Structure
type Candle
    box body
    line upperWick
    line lowerWick
    line o
    line h
    line l
    label labelO
    label labelH
    label labelL
    label labelC

// Helper Functions
getAutoTimeframe(s, m5, m15, m60, m240, m, d, w, q, y) =>
    timeframe.isseconds ? s :
     timeframe.isminutes ? 
      timeframe.multiplier < 5 ? m5 : 
      timeframe.multiplier < 15 ? m15 : 
      timeframe.multiplier < 60 ? m60 :
      timeframe.multiplier < 240 ? m240 : m :
     timeframe.isdaily ? d :
     timeframe.isweekly ? w :
     timeframe.ismonthly and timeframe.multiplier < 6 ? q : y

determineAutoTimeframe() =>
    if tf_2lvs
        getAutoTimeframe('5', '15', '60', '240', '1D', '1W', '1M', '3M', '12M', '12M')
    else
        getAutoTimeframe('1', '5', '15', '60', '240', '1D', '1W', '1M', '3M', '12M')

getSizeMultiplier() =>
    result = switch size
        "Small" => 1
        "Medium" => 2
        "Large" => 3
    result

getLineStyle(style) =>
    result = switch style
        "Solid" => line.style_solid
        "Dotted" => line.style_dotted
        "Dashed" => line.style_dashed
    result

getLabelSize() =>
    result = switch font_size
        "Tiny" => size.tiny
        "Small" => size.small
        "Normal" => size.normal
        "Large" => size.large
        "Huge" => size.huge
    result

// Main Logic
var maxIndex = num - 1
var curr_tf = tf_auto ? determineAutoTimeframe() : tf
var useHtfData = (timeframe.isweekly and htf_data == "Is Weekly") or htf_data == "Always"
var sizeMultiplier = getSizeMultiplier()
newCandle = ta.change(time(curr_tf)) != 0

ohlc() =>
    [htf_o, htf_h, htf_l, htf_c] = request.security(syminfo.tickerid, curr_tf, [open, high, low, close], lookahead=barmerge.lookahead_on)
    var o = 0.
    var h = 0.
    var l = 0.
    c = close

    if newCandle
        o := open
        h := high
        l := low
    else
        h := math.max(high, h)
        l := math.min(low, l)
    
    [o, h, l, c, htf_o, htf_h, htf_l, htf_c]

getCandlePostion(l_pos) =>
    m_pos = l_pos + sizeMultiplier
    r_pos = l_pos + (sizeMultiplier * 2)
    [m_pos, r_pos]

createLabel(r_pos, s) =>
    label.new(r_pos, s, str.tostring(s, format.mintick), style=label.style_label_left, color=color.new(color.black, 100), textcolor=font_color, size=getLabelSize())

createLabels(Candle candle, o, h, l, c, l_pos) =>
    if show_po3 and ohlc_enabled    
        [m_pos, r_pos] = getCandlePostion(l_pos)
        if o_enabled
            candle.labelO := createLabel(r_pos, o)
            candle.labelC := createLabel(r_pos, c)
        if hl_enabled
            candle.labelH := createLabel(r_pos, h)
            candle.labelL := createLabel(r_pos, l)

moveLabel(label la, r_pos, s) =>
    la.set_text(str.tostring(s, format.mintick))
    la.set_xy(r_pos, s)

moveLabels(Candle candle, l_pos, o, h, l, c) =>
    if show_po3
        [m_pos, r_pos] = getCandlePostion(l_pos)
        if o_enabled
            moveLabel(candle.labelO, r_pos, o)
            moveLabel(candle.labelC, r_pos, c)
        if hl_enabled
            moveLabel(candle.labelH, r_pos, h)
            moveLabel(candle.labelL, r_pos, l)

deleteLabels(Candle candle) =>
    if show_po3
        if o_enabled
            candle.labelO.delete()
            candle.labelC.delete()
        if hl_enabled
            candle.labelH.delete()
            candle.labelL.delete()

createProjections(Candle candle, o, h, l, curr_o, curr_h, curr_l, htf_o, htf_h, htf_l, l_pos) =>
    [m_pos, r_pos] = getCandlePostion(l_pos)
    b_o = bar_index
    b_h = bar_index
    b_l = bar_index
    o_o = o
    o_h = h
    o_l = l
    if useHtfData
        if htf_o != o
            b_o := b_o - 1
            o_o := curr_o
        if htf_h != h
            b_h := b_h - 1
            o_h := curr_h
        if htf_l != l
            b_l := b_l - 1
            o_l := curr_l

    if show_po3 and o_enabled  // Dodaj warunek show_po3
        candle.o := line.new(b_o, o_o, m_pos, o_o, style=getLineStyle(o_style), color=o_col, width=o_width)
    if show_po3 and hl_enabled  // Dodaj warunek show_po3
        candle.h := line.new(b_h, o_h, m_pos, o_h, style=getLineStyle(hl_style), color=hl_col, width=hl_width)
        candle.l := line.new(b_l, o_l, m_pos, o_l, style=getLineStyle(hl_style), color=hl_col, width=hl_width)

moveProjections(Candle candle, l_pos, o, h, l, curr_o, curr_h, curr_l) =>
    [m_pos, r_pos] = getCandlePostion(l_pos)
    if show_po3 and o_enabled  // Dodaj warunek show_po3
        candle.o.set_y1(curr_o)
        candle.o.set_xy2(m_pos, curr_o)
    if show_po3 and hl_enabled  // Dodaj warunek show_po3
        old_h = candle.h.get_y1()
        old_l = candle.l.get_y1()

        if h > old_h or (useHtfData and h[1] < old_h)
            candle.h.set_x1(bar_index)
        candle.h.set_y1(curr_h)
        candle.h.set_xy2(m_pos, curr_h)

        if l < old_l or (useHtfData and l[1] > old_l)
            candle.l.set_x1(bar_index)
        candle.l.set_y1(curr_l)
        candle.l.set_xy2(m_pos, curr_l)

deleteProjections(Candle candle) =>
    if show_po3 and o_enabled  // Dodaj warunek show_po3
        candle.o.delete()
    if show_po3 and hl_enabled  // Dodaj warunek show_po3
        candle.h.delete()
        candle.l.delete()

getCandleProperties(o, h, l, c) =>
    h_body = math.max(o, c)
    l_body = math.min(o, c)
    body_col = o > c ? down_col : up_col
    wick_col = o > c ? down_col_wick : up_col_wick
    border_col = o > c ? down_col_border : up_col_border
    [h_body, l_body, body_col, wick_col, border_col]

createCandle(l_pos, o, h, l, c) =>
    [m_pos, r_pos] = getCandlePostion(l_pos)
    [h_body, l_body, body_col, wick_col, border_col] = getCandleProperties(o, h, l, c)
    candle = Candle.new()
    if show_po3
        candle.body := box.new(l_pos, h_body, r_pos, l_body, border_col, bgcolor=body_col)
        candle.upperWick := line.new(m_pos, h_body, m_pos, h, color=wick_col)
        candle.lowerWick := line.new(m_pos, l_body, m_pos, l, color=wick_col)
    candle

moveCandle(Candle candle, l_pos) =>
    [m_pos, r_pos] = getCandlePostion(l_pos)
    candle.body.set_left(l_pos)
    candle.body.set_right(r_pos)
    candle.upperWick.set_x1(m_pos)
    candle.upperWick.set_x2(m_pos)
    candle.lowerWick.set_x1(m_pos)
    candle.lowerWick.set_x2(m_pos)

updateCandle(Candle candle, l_pos, o, h, l, c) =>
    [m_pos, r_pos] = getCandlePostion(l_pos)
    [h_body, l_body, body_col, wick_col, border_col] = getCandleProperties(o, h, l, c)
    if show_po3
        candle.body.set_bgcolor(body_col)
        candle.body.set_lefttop(l_pos, h_body)
        candle.body.set_rightbottom(r_pos, l_body)
        candle.body.set_border_color(border_col)
        candle.upperWick.set_color(wick_col)
        candle.upperWick.set_xy1(m_pos, h_body)
        candle.upperWick.set_xy2(m_pos, h)
        candle.lowerWick.set_color(wick_col)
        candle.lowerWick.set_xy1(m_pos, l_body)
        candle.lowerWick.set_xy2(m_pos, l)
    if show_po3 and ohlc_enabled
        moveLabel(candle.labelC, r_pos, c)

deleteCandle(Candle candle) =>
    if show_po3
        candle.body.delete()
        candle.upperWick.delete()
        candle.lowerWick.delete()
        deleteLabels(candle)
    deleteProjections(candle)

var candles = array.new<Candle>(num, Candle.new())
[o, h, l, c, htf_o, htf_h, htf_l, htf_c] = ohlc()
curr_o = o
curr_h = h
curr_l = l
curr_c = c

if useHtfData
    curr_o := htf_o
    curr_h := htf_h
    curr_l := htf_l
    curr_c := htf_c

candle_o = curr_o
candle_h = curr_h
candle_l = curr_l
candle_c = curr_c

if type == "Heikin Ashi" and not chart.is_heikinashi
    candle_c := (curr_o + curr_h + curr_l + curr_c) / 4
    if newCandle
        candle_o := na(candle_o[1]) ? (curr_o + curr_c) / 2 : (nz(candle_o[1]) + nz(candle_c[1])) / 2
    else
        candle_o := nz(candle_o[1])
    candle_h := math.max(curr_h, candle_o, candle_c) 
    candle_l := math.min(curr_l, candle_o, candle_c)        

if newCandle
    oldCandle = candles.shift()
    deleteCandle(oldCandle)
    pos = bar_index + offset + maxIndex * (3 + sizeMultiplier)
    candle = createCandle(pos, candle_o, candle_h, candle_l, candle_c)
    createProjections(candle, o, h, l, curr_o, curr_h, curr_l, htf_o, htf_h, htf_l, pos)
    createLabels(candle, curr_o, curr_h, curr_l, curr_c, pos)
    candles.push(candle)

for [i, candle] in candles
    new_pos = bar_index + offset + i * (margin + (2 * sizeMultiplier))
    if i < maxIndex
        moveCandle(candle, new_pos)
        deleteProjections(candle) 
        deleteLabels(candle)
    else
        updateCandle(candle, new_pos, candle_o, candle_h, candle_l, candle_c)
        moveProjections(candle, new_pos, o, h, l, curr_o, curr_h, curr_l)
        moveLabels(candle, new_pos, curr_o, curr_h, curr_l, curr_c)

// HTS Wstƒôgi - Tabele trend√≥w
// Pozycja tabeli
tableLocation = input.string('Prawy dolny r√≥g', title='Po≈Ço≈ºenie tabeli z Trendem:', options=['Lewy g√≥rny r√≥g', 'Lewa strona ≈õrodek', 'Lewy dolny r√≥g', '≈örodek g√≥ra', '≈örodek', '≈örodek d√≥≈Ç', 'Prawy g√≥rny r√≥g', 'Prawa strona ≈õrodek', 'Prawy dolny r√≥g'], group=g10)
neutralSymbol = input.string("‚óè", title="Symbol neutralny:", options=["‚óè", "‚è∫", "‚ñ™", "‚ñ†", "üêà", "üê±", "üò∏", "üòπ", "üò∫", "üòª", "üòº", "üòΩ", "üòæ", "üòø", "üôÄ"], group=g10)
rsiLength = input.int(14, title='D≈Çugo≈õƒá RSI:', group=g10)

// Deklaracja zmiennej tabeli
var table trendTable = na

// Zmienna globalna dla pozycji tabeli
var tablePos = position.top_right
switch tableLocation
    'Lewy g√≥rny r√≥g' => tablePos := position.top_left
    'Lewa strona ≈õrodek' => tablePos := position.middle_left
    'Lewy dolny r√≥g' => tablePos := position.bottom_left
    '≈örodek g√≥ra' => tablePos := position.top_center
    '≈örodek' => tablePos := position.middle_center
    '≈örodek d√≥≈Ç' => tablePos := position.bottom_center
    'Prawy g√≥rny r√≥g' => tablePos := position.top_right
    'Prawa strona ≈õrodek' => tablePos := position.middle_right
    'Prawy dolny r√≥g' => tablePos := position.bottom_right

// Aktualizacja tabeli w nowej pozycji
if barstate.isfirst and show_trend_table
    if na(trendTable)
        trendTable := table.new(tablePos, 5, 5, border_width=3)
    else
        table.delete(trendTable)
        trendTable := table.new(tablePos, 5, 5, border_width=3)

// Kolory dla trend√≥w
upColor = #089981
downColor = #f23645
neutralColor = #fbff00

// Warunki trendu
isUptrendAlert = ta.crossover(HTSFastLow, HTSSlowHigh)
isDowntrendAlert = ta.crossunder(HTSFastHigh, HTSSlowLow)

// Funkcja pobierajƒÖca trend z r√≥≈ºnych interwa≈Ç√≥w
f_getTrend() =>
    HTSFastHigh_local = ta.rma(high, lenFast)
    HTSFastLow_local = ta.rma(low, lenFast)
    HTSSlowHigh_local = ta.rma(high, lenSlow)
    HTSSlowLow_local = ta.rma(low, lenSlow)
    isUptrend_local = HTSFastLow_local > HTSSlowHigh_local
    isDowntrend_local = HTSFastHigh_local < HTSSlowLow_local
    [isUptrend_local, isDowntrend_local]

// Funkcja wype≈ÇniajƒÖca kom√≥rki tabeli
f_fillCell(_column, _row, _cellText, _c_color, _text_color) =>
    table.cell(trendTable, _column, _row, _cellText, bgcolor=color.new(_c_color, 90), text_color=_text_color, height=3, width=4)

// Funkcje sprawdzajƒÖce pozycjƒô ceny wzglƒôdem wstƒôg dla r√≥≈ºnych interwa≈Ç√≥w
f_getPriceBandPosition() =>
    priceAboveFast = close > HTSFastHigh
    priceInsideFast = close < HTSFastHigh and close > HTSFastLow
    priceBelowFast = close < HTSFastLow

    priceAboveSlow = close > HTSSlowHigh
    priceInsideSlow = close < HTSSlowHigh and close > HTSSlowLow
    priceBelowSlow = close < HTSSlowLow

    [priceAboveFast, priceInsideFast, priceBelowFast, priceAboveSlow, priceInsideSlow, priceBelowSlow]

// Funkcja okre≈õlajƒÖca kolor kom√≥rki RSI
f_rsiColor(rsi) =>
    rsi > 70 ? downColor : rsi < 30 ? #00e676 : upColor

// Funkcja do konwersji interwa≈Çu na przyjaznƒÖ nazwƒô
f_intervalToLabel(interval) =>
    if interval == '1'
        'm1'
    else if interval == '3'
        'm3'
    else if interval == '5'
        'm5'
    else if interval == '15'
        'm15'
    else if interval == '30'
        'm30'
    else if interval == '45'
        'm45'
    else if interval == '60'
        'H1'
    else if interval == '120'
        'H2'
    else if interval == '180'
        'H3'
    else if interval == '240'
        'H4'
    else if interval == 'D'
        'D1'
    else if interval == 'W'
        'W1'
    else if interval == 'M'
        'M1'
    else
        interval  // Domy≈õlnie zwr√≥ƒá warto≈õƒá wej≈õciowƒÖ, je≈õli nie pasuje do ≈ºadnego przypadku

// Dodaj nowe zmienne wej≈õciowe dla interwa≈Ç√≥w
firstInterval = input.timeframe('1', title="Pierwszy interwa≈Ç dla Trendu:", group=g10a)
secondInterval = input.timeframe('5', title="Drugi interwa≈Ç dla Trendu:", group=g10a)
thirdInterval = input.timeframe('60', title="Trzeci interwa≈Ç dla Trendu:", group=g10a)
fourthInterval = input.timeframe('D', title="Czwarty interwa≈Ç dla Trendu:", group=g10a)

// Pobieranie trend√≥w z r√≥≈ºnych interwa≈Ç√≥w czasowych (u≈ºywajƒÖc wybranych interwa≈Ç√≥w)
[up_01, down_01] = request.security(syminfo.tickerid, firstInterval, f_getTrend())
[up_02, down_02] = request.security(syminfo.tickerid, secondInterval, f_getTrend())
[up_03, down_03] = request.security(syminfo.tickerid, thirdInterval, f_getTrend())
[up_04, down_04] = request.security(syminfo.tickerid, fourthInterval, f_getTrend())

// Generowanie symboli strza≈Ç√≥w dla r√≥≈ºnych interwa≈Ç√≥w
glyph1 = up_01 ? '‚ñ≤ ' : down_01 ? '‚ñº ' : neutralSymbol + ' '
glyph2 = up_02 ? '‚ñ≤ ' : down_02 ? '‚ñº ' : neutralSymbol + ' '
glyph3 = up_03 ? '‚ñ≤ ' : down_03 ? '‚ñº ' : neutralSymbol + ' '
glyph4 = up_04 ? '‚ñ≤ ' : down_04 ? '‚ñº ' : neutralSymbol + ' '

// Pobieranie pozycji ceny dla r√≥≈ºnych interwa≈Ç√≥w
[aboveF_01, insideF_01, belowF_01, aboveS_01, insideS_01, belowS_01] = request.security(syminfo.tickerid, firstInterval, f_getPriceBandPosition())
[aboveF_02, insideF_02, belowF_02, aboveS_02, insideS_02, belowS_02] = request.security(syminfo.tickerid, secondInterval, f_getPriceBandPosition())
[aboveF_03, insideF_03, belowF_03, aboveS_03, insideS_03, belowS_03] = request.security(syminfo.tickerid, thirdInterval, f_getPriceBandPosition())
[aboveF_04, insideF_04, belowF_04, aboveS_04, insideS_04, belowS_04] = request.security(syminfo.tickerid, fourthInterval, f_getPriceBandPosition())

// Pobieranie warto≈õci RSI dla r√≥≈ºnych interwa≈Ç√≥w
rsi_01 = request.security(syminfo.tickerid, firstInterval, ta.rsi(close, rsiLength))
rsi_02 = request.security(syminfo.tickerid, secondInterval, ta.rsi(close, rsiLength))
rsi_03 = request.security(syminfo.tickerid, thirdInterval, ta.rsi(close, rsiLength))
rsi_04 = request.security(syminfo.tickerid, fourthInterval, ta.rsi(close, rsiLength))

// W sekcji if barstate.islast dodaj po pierwszym wierszu:
if barstate.islast and show_trend_table
    // Pierwszy wiersz - trend (pozostaw bez zmian)
    f_fillCell(1, 0, glyph1 + f_intervalToLabel(firstInterval), up_01 ? upColor : down_01 ? downColor : neutralColor, up_01 ? upColor : down_01 ? downColor : neutralColor)
    f_fillCell(2, 0, glyph2 + f_intervalToLabel(secondInterval), up_02 ? upColor : down_02 ? downColor : neutralColor, up_02 ? upColor : down_02 ? downColor : neutralColor)
    f_fillCell(3, 0, glyph3 + f_intervalToLabel(thirdInterval), up_03 ? upColor : down_03 ? downColor : neutralColor, up_03 ? upColor : down_03 ? downColor : neutralColor)
    f_fillCell(4, 0, glyph4 + f_intervalToLabel(fourthInterval), up_04 ? upColor : down_04 ? downColor : neutralColor, up_04 ? upColor : down_04 ? downColor : neutralColor)

    // Drugi wiersz - pozycja wzglƒôdem szybkiej wstƒôgi
    f_fillCell(1, 1, aboveF_01 ? '‚ñ≤' : insideF_01 ? neutralSymbol : '‚ñº', aboveF_01 ? upColor : insideF_01 ? neutralColor : downColor, aboveF_01 ? upColor : insideF_01 ? neutralColor : downColor)
    f_fillCell(2, 1, aboveF_02 ? '‚ñ≤' : insideF_02 ? neutralSymbol : '‚ñº', aboveF_02 ? upColor : insideF_02 ? neutralColor : downColor, aboveF_02 ? upColor : insideF_02 ? neutralColor : downColor)
    f_fillCell(3, 1, aboveF_03 ? '‚ñ≤' : insideF_03 ? neutralSymbol : '‚ñº', aboveF_03 ? upColor : insideF_03 ? neutralColor : downColor, aboveF_03 ? upColor : insideF_03 ? neutralColor : downColor)
    f_fillCell(4, 1, aboveF_04 ? '‚ñ≤' : insideF_04 ? neutralSymbol : '‚ñº', aboveF_04 ? upColor : insideF_04 ? neutralColor : downColor, aboveF_04 ? upColor : insideF_04 ? neutralColor : downColor)

    // Trzeci wiersz - pozycja wzglƒôdem wolnej wstƒôgi
    f_fillCell(1, 2, aboveS_01 ? '‚ñ≤' : insideS_01 ? neutralSymbol : '‚ñº', aboveS_01 ? upColor : insideS_01 ? neutralColor : downColor, aboveS_01 ? upColor : insideS_01 ? neutralColor : downColor)
    f_fillCell(2, 2, aboveS_02 ? '‚ñ≤' : insideS_02 ? neutralSymbol : '‚ñº', aboveS_02 ? upColor : insideS_02 ? neutralColor : downColor, aboveS_02 ? upColor : insideS_02 ? neutralColor : downColor)
    f_fillCell(3, 2, aboveS_03 ? '‚ñ≤' : insideS_03 ? neutralSymbol : '‚ñº', aboveS_03 ? upColor : insideS_03 ? neutralColor : downColor, aboveS_03 ? upColor : insideS_03 ? neutralColor : downColor)
    f_fillCell(4, 2, aboveS_04 ? '‚ñ≤' : insideS_04 ? neutralSymbol : '‚ñº', aboveS_04 ? upColor : insideS_04 ? neutralColor : downColor, aboveS_04 ? upColor : insideS_04 ? neutralColor : downColor)

    // HTS Wstƒôgi - RSI w Tabeli trend√≥w
    // Czwarty wiersz - warto≈õci RSI (tylko je≈õli show_rsi_row jest w≈ÇƒÖczone)
    if show_rsi_row
        f_fillCell(1, 3, str.tostring(rsi_01, '#.0'), f_rsiColor(rsi_01), f_rsiColor(rsi_01))
        f_fillCell(2, 3, str.tostring(rsi_02, '#.0'), f_rsiColor(rsi_02), f_rsiColor(rsi_02))
        f_fillCell(3, 3, str.tostring(rsi_03, '#.0'), f_rsiColor(rsi_03), f_rsiColor(rsi_03))
        f_fillCell(4, 3, str.tostring(rsi_04, '#.0'), f_rsiColor(rsi_04), f_rsiColor(rsi_04))

    // Dodanie piƒÖtej kolumny z etykietami  
    f_fillCell(0, 0, 'Trend:', #808080, #808080)
    f_fillCell(0, 1, str.tostring(lenFast), #808080, HTSFastColor)
    f_fillCell(0, 2, str.tostring(lenSlow), #808080, HTSSlowColor)
    if show_rsi_row
        f_fillCell(0, 3, 'RSI:', #808080, #808080)

// HTS Wstƒôgi - Alarmy
alertcondition(isUptrendAlert, title='Trend wzrostowy - przeciƒôcie wstƒôg', message='Trend wzrostowy! - Szybsza przecina wolniejszƒÖ w kierunku wzrostowym')
alertcondition(isDowntrendAlert, title='Trend spadkowy - przeciƒôcie wstƒôg', message='Trend spadkowy! - Szybsza przecina wolniejszƒÖ w kierunku spadkowym')
alertcondition(ta.cross(close, vwapValue), title="Przeciƒôcie ceny - VWAP", message="Cena przekroczy≈Ça liniƒô VWAP")
alertcondition(alert_pp, title="Przeciƒôcie ceny - PP", message="Cena przekroczy≈Ça poziom PP")
alertcondition(alert_s1, title="Przeciƒôcie ceny - S1", message="Cena przekroczy≈Ça poziom S1")
alertcondition(alert_s2, title="Przeciƒôcie ceny - S2", message="Cena przekroczy≈Ça poziom S2")
alertcondition(alert_s3, title="Przeciƒôcie ceny - S3", message="Cena przekroczy≈Ça poziom S3")
alertcondition(alert_s4, title="Przeciƒôcie ceny - S4", message="Cena przekroczy≈Ça poziom S4")
alertcondition(alert_s5, title="Przeciƒôcie ceny - S5", message="Cena przekroczy≈Ça poziom S5")
alertcondition(alert_r1, title="Przeciƒôcie ceny - R1", message="Cena przekroczy≈Ça poziom R1")
alertcondition(alert_r2, title="Przeciƒôcie ceny - R2", message="Cena przekroczy≈Ça poziom R2")
alertcondition(alert_r3, title="Przeciƒôcie ceny - R3", message="Cena przekroczy≈Ça poziom R3")
alertcondition(alert_r4, title="Przeciƒôcie ceny - R4", message="Cena przekroczy≈Ça poziom R4")
alertcondition(alert_r5, title="Przeciƒôcie ceny - R5", message="Cena przekroczy≈Ça poziom R5")
