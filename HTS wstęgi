// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © xwaytheory

//@version=6
indicator(title='HTS - Wstęgi', overlay=true)

// HTS Wstęgi - Tytuły
t1 = '1. Pokaż - HTS Wstęgi - Główne'
t2 = '2. Pokaż - HTS Wstęgi - Drugi interwał czasowy'
t3 = '3. Pokaż - Koloryzowanie świec'
t4 = '4. Pokaż - Double EMA'
t5 = '5. Pokaż - Pivot Points'
t6 = '6. Pokaż - Kijun-Sen'
t7 = '7. Pokaż - Kijun-Sen - Drugi interwał czasowy'
t8 = '8. Pokaż - VWAP'
t9 = '9. Pokaż - PO3 - Power of Three'
t10 = '10. Pokaż - Tabele trendów'
t10A = '10. a) Pokaż - RSI w Tabeli trendów'

// HTS Wstęgi - Grupy
g0 = 'HTS - Wstęgi - Włącz/Wyłącz wskaźniki'
g2 = '1. HTS Wstegi - główny interwał czasowy - ustawienia'
g3 = '2. HTS Wstęgi - Drugi interwał czasowy - ustawienia'
g4 = '3. Koloryzowanie świec - ustawienia'
g5 = '4. Double EMA - ustawienia'
g6 = '5. Pivot Points - ustawienia'
g7 = '6. Kijun-Sen - ustawienia'
g7a = '7. Kijun-Sen - Drugi interwał czasowy - ustawienia'
g8 = '8. VWAP - Volume Weighted Average Price - ustawienia'
g9 = '9. PO3 - Power of Three - ustawienia'
g9a = '9. a) PO3 - Power of Three - kolory świeczki w góre - ustawienia'
g9b = '9. b) PO3 - Power of Three - kolory świeczki w dół - ustawienia'
g9c = '9. c) PO3 - Power of Three - projekcja świeczki - ustawienia'
g10 = '10. Tabela trendów - ustawienia'
g10a = '10. a) Tabela trendów - interwały - ustawienia'

// HTS Wstęgi - Włącz/Wyłącz
show_hts = input.bool(true, title=t1, group=g0)
show_hts2 = input.bool(false, title=t2, group=g0)
show_candle_coloring = input.bool(false, title=t3, group=g0)
show_double_ema = input.bool(false, title=t4, group=g0)
show_pivot_points = input(false, title=t5, group=g0)
show_kijun_sen = input.bool(false, title=t6, group=g0)
show_kijun_sen2 = input.bool(false, title=t7, group=g0)
show_vwap = input.bool(false, title=t8, group=g0)
var show_po3 = input.bool(false, title=t9, group=g0)
show_trend_table = input.bool(true, title=t10, group=g0)
show_rsi_row = input.bool(false, title=t10A, group=g0)

// HTS Wstęgi - Główne
// Metoda obliczania średnich kroczących dla głównego interwału
mamethod = input.string(title='Metoda wstęg HTS:', defval='RMA', options=['RMA', 'EMA', 'SMA', 'WMA', 'VWMA'], group=g2)

// Funkcja do obliczania różnych typów średnich kroczących
plotmafunc(isrc, ilength, itype) =>
    switch itype
        'RMA' => ta.rma(isrc, ilength)
        'EMA' => ta.ema(isrc, ilength)
        'SMA' => ta.sma(isrc, ilength)
        'WMA' => ta.wma(isrc, ilength)
        'VWMA' => ta.vwma(isrc, ilength)

// Długości
lenFast = input.int(33, title='Długość szybszej wstęgi HTS:', group=g2)
lenSlow = input.int(144, title='Długość wolniejszej wstęgi HTS:', group=g2)

// Kolory dla HTS (Średnie kroczące)
HTSFastColor = input.color(color.new(#00bbd4, 70), title='Kolor szybszej wstęgi HTS:', group=g2)
HTSSlowColor = input.color(color.new(#ff5252, 70), title='Kolor wolniejszej wstęgi HTS:', group=g2)

// Obliczenie szybkich i wolnych HTS
HTSFastHigh = plotmafunc(high, lenFast, mamethod)
HTSFastLow = plotmafunc(low, lenFast, mamethod)
HTSSlowHigh = plotmafunc(high, lenSlow, mamethod)
HTSSlowLow = plotmafunc(low, lenSlow, mamethod)

// Kolory tła wstęg
HTSFastFillColor = input.color(color.new(#00bbd4, 95), title='Kolor wypełnienia szybszej wstęgi HTS:', group=g2)
HTSSlowFillColor = input.color(color.new(#ff5252, 95), title='Kolor wypełnienia wolniejszej wstęgi HTS:', group=g2)

// Definicja trendów na podstawie HTS
isUptrend = HTSFastLow > HTSSlowHigh or HTSFastLow > HTSSlowLow
isDowntrend = HTSFastHigh < HTSSlowLow or HTSFastHigh < HTSSlowHigh

// Rysowanie punktów przecięcia dla HTS - Kolory
uptrendUpGreenDot = input.color(color.new(#00bbd4, 40), title='Kropka - Przecięcie HTS Wstęg w góre - Trend wzrostowy:', group=g2)
downtrendUpGreenDot = input.color(color.new(#4caf50, 100), title='Kropka - Możliwe przecięcie HTS Wstęg w góre - Trend spadkowy:', group=g2)
uptrendDownRedDot = input.color(color.new(#ff5252, 100), title='Kropka - Możliwe przecięcie HTS Wstęg w dół - Trend spadkowy:', group=g2)
downtrendDownRedDot = input.color(color.new(#00bbd4, 40), title='Kropka - Przecięcie HTS Wstęg w dół - Trend spadkowy:', group=g2)

// Rysowanie HTS z możliwością zmiany kolorów
plot_HTSFastHigh = plot(show_hts ? HTSFastHigh : na, color=HTSFastColor, linewidth=1, title='HTS szybszej High:')
plot_HTSFastLow = plot(show_hts ? HTSFastLow : na, color=HTSFastColor, linewidth=1, title='HTS szybszej Low:')
plot_HTSSlowHigh = plot(show_hts ? HTSSlowHigh : na, color=HTSSlowColor, linewidth=1, title=' HTS wolnej High:')
plot_HTSSlowLow = plot(show_hts ? HTSSlowLow : na, color=HTSSlowColor, linewidth=1, title='HTS wolnej Low:')

// Wypełnienie tła między HTS dla lepszej wizualizacji
fill(plot_HTSFastHigh, plot_HTSFastLow, title='Wypełnienie szybszej wstęgi HTS:', color=show_hts ? HTSFastFillColor : na)
fill(plot_HTSSlowHigh, plot_HTSSlowLow, title='Wypełnienie wolniejszej wstęgi HTS:', color=show_hts ? HTSSlowFillColor : na)

// Rysowanie punktów przecięcia dla HTS
plot(show_hts and ta.cross(HTSFastLow, HTSSlowHigh) ? HTSSlowHigh : na, color=ta.crossover(HTSFastLow, HTSSlowHigh) ? uptrendUpGreenDot : uptrendDownRedDot, style=plot.style_circles, linewidth=3, title='Przecięcie szybszej Low z wolniejszą Hig:')
plot(show_hts and ta.cross(HTSFastHigh, HTSSlowLow) ? HTSSlowLow : na, color=ta.crossover(HTSFastHigh, HTSSlowLow) ? downtrendUpGreenDot : downtrendDownRedDot, style=plot.style_circles, linewidth=3, title='Przecięcie szybszej High z wolniejszą Low:')

// HTS Wstęgi - Drugi interwał czasowy
// Ustawienia dla drugiego interwału
tf2 = input.timeframe(title='HTS - Drugi interwał czasowy:', defval='60', group=g3)
mamethod2 = input.string(title='Metoda wstęg HTS - Drugi interwał czasowy:', defval='RMA', options=['RMA', 'EMA', 'SMA', 'WMA', 'VWMA'], group=g3)
shortval2 = input.int(33, title='Długość szybszej wstęgi HTS - Drugi interwał czasowy:', group=g3)
longval2 = input.int(144, title='Długość wolniejszej wstęgi HTS - Drugi interwał czasowy:', group=g3)
shortcol2 = input.color(color.new(#00bbd4, 80), title='Kolor szybszej wstęgi HTS - Drugi interwał czasowy:', group=g3)
longcol2 = input.color(color.new(#ff5252, 80), title='Kolor wolniejszej wstęgi HTS - Drugi interwał czasowy:', group=g3)

// Rysowanie średnich kroczących dla drugiego interwału
plotsh2 = plot(show_hts2 ? request.security(syminfo.tickerid, tf2, plotmafunc(high, shortval2, mamethod2), gaps=barmerge.gaps_on) : na, color=shortcol2, linewidth=1, title='HTS Szybsza High - Drugi interwał czasowy:')
plotsl2 = plot(show_hts2 ? request.security(syminfo.tickerid, tf2, plotmafunc(low, shortval2, mamethod2), gaps=barmerge.gaps_on) : na, color=shortcol2, linewidth=1, title='HTS Szybsza Low - Drugi interwał czasowy:')
plotlh2 = plot(show_hts2 ? request.security(syminfo.tickerid, tf2, plotmafunc(high, longval2, mamethod2), gaps=barmerge.gaps_on) : na, color=longcol2, linewidth=1, title='HTS Wolna High - Drugi interwał czasowy:')
plotll2 = plot(show_hts2 ? request.security(syminfo.tickerid, tf2, plotmafunc(low, longval2, mamethod2), gaps=barmerge.gaps_on) : na, color=longcol2, linewidth=1, title='HTS Wolna Low - Drugi interwał czasowy:')

// HTS Wstęgi - Koloryzowanie świec
// Dodanie możliwości wyboru interwału dla koloryzacji świec
candle_coloring_tf = input.timeframe("", title="Interwał dla koloryzacji świec:", group=g4)

// Pobranie wartości HTS z wybranego interwału
h1_hts_high = request.security(syminfo.tickerid, candle_coloring_tf, HTSFastHigh, lookahead=barmerge.lookahead_on)
h1_hts_low = request.security(syminfo.tickerid, candle_coloring_tf, HTSFastLow, lookahead=barmerge.lookahead_on)

// Kolory dla świec - ustawienia użytkownika
candle_up_color = input.color(#089981, title="Kolor świec nad HTS H1:", group=g4)
candle_down_color = input.color(#f23645, title="Kolor świec pod HTS H1:", group=g4)
candle_neutral_color = input.color(#b2b5be, title="Kolor świec wewnątrz HTS H1:", group=g4)

// Funkcja do określania koloru świecy na podstawie HTS H1
f_getCandleColor() =>
    if show_candle_coloring
        if close > h1_hts_high
            candle_up_color
        else if close < h1_hts_low
            candle_down_color
        else
            candle_neutral_color
    else
        na

// Zastosowanie kolorów do świec na wykresie
candle_color = f_getCandleColor()
plotcandle(open, high, low, close, color=candle_color, wickcolor=candle_color, bordercolor=candle_color)


// HTS Wstęgi - Double EMA
// Ustawienia dla Double EMA
len1 = input.int(9, minval=1, title="Długość pierwszej EMA", group=g5)
len2 = input.int(21, minval=1, title="Długość drugiej EMA", group=g5)
ema1_color = input.color(color.blue, title="Kolor pierwszej EMA", group=g5)
ema2_color = input.color(color.red, title="Kolor drugiej EMA", group=g5)

// Obliczenie EMA
ema1 = ta.ema(close, len1)
ema2 = ta.ema(close, len2)

// Rysowanie EMA na wykresie
plot(show_double_ema ? ema1 : na, title="EMA 1", color=ema1_color, linewidth=1)
plot(show_double_ema ? ema2 : na, title="EMA 2", color=ema2_color, linewidth=1)

// HTS Wstęgi - Pivot Points
// Ustawienia dla Pivot Points
AUTO = 'Auto'
DAILY = 'Daily'
WEEKLY = 'Weekly'
MONTHLY = 'Monthly'
QUARTERLY = 'Quarterly'
YEARLY = 'Yearly'
BIYEARLY = 'Biyearly'
TRIYEARLY = 'Triyearly'
QUINQUENNIALLY = 'Quinquennially'
DECENNIALLY = 'Decennially'

TRADITIONAL = 'Traditional'
FIBONACCI = 'Fibonacci'
WOODIE = 'Woodie'
CLASSIC = 'Classic'
DEMARK = 'DM'
CAMARILLA = 'Camarilla'

kind = input.string('Traditional', title='Typ Pivot Points:', options=[TRADITIONAL, FIBONACCI, WOODIE, CLASSIC, DEMARK, CAMARILLA], group=g6)
look_back = input.int(1, title='Ilość Pivot Points w tył:', minval=1, maxval=5000)
pivot_time_frame = input.string(DAILY, title='Interwał czasowy dla Pivot Points:', options=[AUTO, DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY, BIYEARLY, TRIYEARLY, QUINQUENNIALLY, DECENNIALLY])
is_daily_based = input.bool(true, title='Użyj wartości dziennych dla Pivot Points:', tooltip='Gdy ta opcja jest odznaczona, punkty osiowe będą używały danych śróddziennych podczas obliczania na wykresach śróddziennych. Jeśli na wykresie wyświetlane są godziny rozszerzone, zostaną one uwzględnione podczas obliczania poziomów osiowych. Jeśli śróddzienne wartości OHLC różnią się od wartości dziennych (normalne w przypadku akcji), poziomy osiowe również będą się różnić.')
show_labels = input.bool(true, title='Pokaż oznaczenia Pivot Points:', group=g6)
show_prices = input.bool(true, title='Pokaż wartości Pivot Points:', group=g6)
position_labels = input.string('Prawa', 'Po której stronie oznaczenia dla Pivot Points:', options=['Lewa', 'Prawa'], group=g6)
line_width = input.int(1, title='Grubość lini Pivot Points:', minval=1, maxval=100, group=g6)

var DEF_COLOR = #808080
var DEF_COLOR_P = #b2b5be
var DEF_COLOR_S = #4caf50
var DEF_COLOR_R = #f05350
var arr_time = array.new_int()
var p = array.new_float()
p_color = input.color(DEF_COLOR_P, 'P‏  ‏  ‏', inline='P', group=g6)
p_show = input.bool(true, '', inline='P', group=g6)
var r1 = array.new_float()
var s1 = array.new_float()
s1_color = input.color(DEF_COLOR_S, 'S1', inline='S1/R1', group=g6)
s1_show = input.bool(true, '', inline='S1/R1', group=g6)
r1_color = input.color(DEF_COLOR_R, '‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R1', inline='S1/R1', group=g6)
r1_show = input.bool(true, '', inline='S1/R1', group=g6)
var r2 = array.new_float()
var s2 = array.new_float()
s2_color = input.color(DEF_COLOR_S, 'S2', inline='S2/R2', group=g6)
s2_show = input.bool(true, '', inline='S2/R2', group=g6)
r2_color = input.color(DEF_COLOR_R, '‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R2', inline='S2/R2', group=g6)
r2_show = input.bool(true, '', inline='S2/R2', group=g6)
var r3 = array.new_float()
var s3 = array.new_float()
s3_color = input.color(DEF_COLOR_S, 'S3', inline='S3/R3', group=g6)
s3_show = input.bool(true, '', inline='S3/R3', group=g6)
r3_color = input.color(DEF_COLOR_R, '‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R3', inline='S3/R3', group=g6)
r3_show = input.bool(true, '', inline='S3/R3', group=g6)
var r4 = array.new_float()
var s4 = array.new_float()
s4_color = input.color(DEF_COLOR_S, 'S4', inline='S4/R4', group=g6)
s4_show = input.bool(false, '', inline='S4/R4', group=g6)
r4_color = input.color(DEF_COLOR_R, '‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R4', inline='S4/R4', group=g6)
r4_show = input.bool(false, '', inline='S4/R4', group=g6)
var r5 = array.new_float()
var s5 = array.new_float()
s5_color = input.color(DEF_COLOR_S, 'S5', inline='S5/R5', group=g6)
s5_show = input.bool(false, '', inline='S5/R5', group=g6)
r5_color = input.color(DEF_COLOR_R, '‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R5', inline='S5/R5', group=g6)
r5_show = input.bool(false, '', inline='S5/R5', group=g6)

pivotX_open = float(na)
pivotX_open := nz(pivotX_open[1], open)
pivotX_high = float(na)
pivotX_high := nz(pivotX_high[1], high)
pivotX_low = float(na)
pivotX_low := nz(pivotX_low[1], low)
pivotX_prev_open = float(na)
pivotX_prev_open := nz(pivotX_prev_open[1])
pivotX_prev_high = float(na)
pivotX_prev_high := nz(pivotX_prev_high[1])
pivotX_prev_low = float(na)
pivotX_prev_low := nz(pivotX_prev_low[1])
pivotX_prev_close = float(na)
pivotX_prev_close := nz(pivotX_prev_close[1])

get_pivot_resolution() =>
    resolution = 'M'
    if pivot_time_frame == AUTO
        if timeframe.isintraday
            resolution := timeframe.multiplier <= 15 ? 'D' : 'W'
        else if timeframe.isweekly or timeframe.ismonthly
            resolution := '12M'
    else if pivot_time_frame == DAILY
        resolution := 'D'
    else if pivot_time_frame == WEEKLY
        resolution := 'W'
    else if pivot_time_frame == MONTHLY
        resolution := 'M'
    else if pivot_time_frame == QUARTERLY
        resolution := '3M'
    else if pivot_time_frame == YEARLY or pivot_time_frame == BIYEARLY or pivot_time_frame == TRIYEARLY or pivot_time_frame == QUINQUENNIALLY or pivot_time_frame == DECENNIALLY
        resolution := '12M'
    resolution

var lines = array.new_line()
var labels = array.new_label()

draw_line(i, pivot, col) =>
    if array.size(arr_time) > 1
        array.push(lines, line.new(array.get(arr_time, i), array.get(pivot, i), array.get(arr_time, i + 1), array.get(pivot, i), color=col, xloc=xloc.bar_time, width=line_width))

draw_label(i, y, txt, txt_color) =>
    if (show_labels or show_prices) and not na(y)
        display_text = (show_labels ? txt : '') + (show_prices ? str.format(' ({0})', math.round_to_mintick(y)) : '')
        label_style = position_labels == 'Prawa' ? label.style_label_left : label.style_label_right
        x = position_labels == 'Lewa' ? array.get(arr_time, i) : array.get(arr_time, i + 1)
        array.push(labels, label.new(x=x, y=y, text=display_text, textcolor=txt_color, style=label_style, color=#00000000, xloc=xloc.bar_time))

traditional() =>
    pivotX_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_prev_close) / 3
    array.push(p, pivotX_Median)
    array.push(r1, pivotX_Median * 2 - pivotX_prev_low)
    array.push(s1, pivotX_Median * 2 - pivotX_prev_high)
    array.push(r2, pivotX_Median + 1 * (pivotX_prev_high - pivotX_prev_low))
    array.push(s2, pivotX_Median - 1 * (pivotX_prev_high - pivotX_prev_low))
    array.push(r3, pivotX_Median * 2 + pivotX_prev_high - 2 * pivotX_prev_low)
    array.push(s3, pivotX_Median * 2 - (2 * pivotX_prev_high - pivotX_prev_low))
    array.push(r4, pivotX_Median * 3 + pivotX_prev_high - 3 * pivotX_prev_low)
    array.push(s4, pivotX_Median * 3 - (3 * pivotX_prev_high - pivotX_prev_low))
    array.push(r5, pivotX_Median * 4 + pivotX_prev_high - 4 * pivotX_prev_low)
    array.push(s5, pivotX_Median * 4 - (4 * pivotX_prev_high - pivotX_prev_low))

fibonacci() =>
    pivotX_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_prev_close) / 3
    pivot_range = pivotX_prev_high - pivotX_prev_low
    array.push(p, pivotX_Median)
    array.push(r1, pivotX_Median + 0.382 * pivot_range)
    array.push(s1, pivotX_Median - 0.382 * pivot_range)
    array.push(r2, pivotX_Median + 0.618 * pivot_range)
    array.push(s2, pivotX_Median - 0.618 * pivot_range)
    array.push(r3, pivotX_Median + 1 * pivot_range)
    array.push(s3, pivotX_Median - 1 * pivot_range)

woodie() =>
    pivotX_Woodie_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_open * 2) / 4
    pivot_range = pivotX_prev_high - pivotX_prev_low
    array.push(p, pivotX_Woodie_Median)
    array.push(r1, pivotX_Woodie_Median * 2 - pivotX_prev_low)
    array.push(s1, pivotX_Woodie_Median * 2 - pivotX_prev_high)
    array.push(r2, pivotX_Woodie_Median + 1 * pivot_range)
    array.push(s2, pivotX_Woodie_Median - 1 * pivot_range)
    pivot_point_r3 = pivotX_prev_high + 2 * (pivotX_Woodie_Median - pivotX_prev_low)
    pivot_point_s3 = pivotX_prev_low - 2 * (pivotX_prev_high - pivotX_Woodie_Median)
    array.push(r3, pivot_point_r3)
    array.push(s3, pivot_point_s3)
    array.push(r4, pivot_point_r3 + pivot_range)
    array.push(s4, pivot_point_s3 - pivot_range)

classic() =>
    pivotX_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_prev_close) / 3
    pivot_range = pivotX_prev_high - pivotX_prev_low
    array.push(p, pivotX_Median)
    array.push(r1, pivotX_Median * 2 - pivotX_prev_low)
    array.push(s1, pivotX_Median * 2 - pivotX_prev_high)
    array.push(r2, pivotX_Median + 1 * pivot_range)
    array.push(s2, pivotX_Median - 1 * pivot_range)
    array.push(r3, pivotX_Median + 2 * pivot_range)
    array.push(s3, pivotX_Median - 2 * pivot_range)
    array.push(r4, pivotX_Median + 3 * pivot_range)
    array.push(s4, pivotX_Median - 3 * pivot_range)

demark() =>
    pivotX_Demark_X = pivotX_prev_high + pivotX_prev_low * 2 + pivotX_prev_close
    if pivotX_prev_close == pivotX_prev_open
        pivotX_Demark_X := pivotX_prev_high + pivotX_prev_low + pivotX_prev_close * 2
    if pivotX_prev_close > pivotX_prev_open
        pivotX_Demark_X := pivotX_prev_high * 2 + pivotX_prev_low + pivotX_prev_close
    array.push(p, pivotX_Demark_X / 4)
    array.push(r1, pivotX_Demark_X / 2 - pivotX_prev_low)
    array.push(s1, pivotX_Demark_X / 2 - pivotX_prev_high)

camarilla() =>
    pivotX_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_prev_close) / 3
    pivot_range = pivotX_prev_high - pivotX_prev_low
    array.push(p, pivotX_Median)
    array.push(r1, pivotX_prev_close + pivot_range * 1.1 / 12.0)
    array.push(s1, pivotX_prev_close - pivot_range * 1.1 / 12.0)
    array.push(r2, pivotX_prev_close + pivot_range * 1.1 / 6.0)
    array.push(s2, pivotX_prev_close - pivot_range * 1.1 / 6.0)
    array.push(r3, pivotX_prev_close + pivot_range * 1.1 / 4.0)
    array.push(s3, pivotX_prev_close - pivot_range * 1.1 / 4.0)
    array.push(r4, pivotX_prev_close + pivot_range * 1.1 / 2.0)
    array.push(s4, pivotX_prev_close - pivot_range * 1.1 / 2.0)
    r5_val = pivotX_prev_high / pivotX_prev_low * pivotX_prev_close
    array.push(r5, r5_val)
    array.push(s5, 2 * pivotX_prev_close - r5_val)

calc_pivot() =>
    if kind == TRADITIONAL
        traditional()
    else if kind == FIBONACCI
        fibonacci()
    else if kind == WOODIE
        woodie()
    else if kind == CLASSIC
        classic()
    else if kind == DEMARK
        demark()
    else if kind == CAMARILLA
        camarilla()

resolution = get_pivot_resolution()

SIMPLE_DIVISOR = -1
custom_years_divisor = switch pivot_time_frame
    BIYEARLY => 2
    TRIYEARLY => 3
    QUINQUENNIALLY => 5
    DECENNIALLY => 10
    => SIMPLE_DIVISOR

calc_high(prev, curr) =>
    if na(prev) or na(curr)
        nz(prev, nz(curr, na))
    else
        math.max(prev, curr)

calc_low(prev, curr) =>
    if not na(prev) and not na(curr)
        math.min(prev, curr)
    else
        nz(prev, nz(curr, na))

calc_OHLC_for_pivot(custom_years_divisor) =>
    if custom_years_divisor == SIMPLE_DIVISOR
        [open, high, low, close, open[1], high[1], low[1], close[1], time[1], time_close]
    else
        var prev_sec_open = float(na)
        var prev_sec_high = float(na)
        var prev_sec_low = float(na)
        var prev_sec_close = float(na)
        var prev_sec_time = int(na)
        var curr_sec_open = float(na)
        var curr_sec_high = float(na)
        var curr_sec_low = float(na)
        var curr_sec_close = float(na)
        if year(time_close) % custom_years_divisor == 0
            curr_sec_open := open
            curr_sec_high := high
            curr_sec_low := low
            curr_sec_close := close
            prev_sec_high := high[1]
            prev_sec_low := low[1]
            prev_sec_close := close[1]
            prev_sec_time := time[1]
            for i = 2 to custom_years_divisor by 1
                prev_sec_open := nz(open[i], prev_sec_open)
                prev_sec_high := calc_high(prev_sec_high, high[i])
                prev_sec_low := calc_low(prev_sec_low, low[i])
                prev_sec_time := nz(time[i], prev_sec_time)
        [curr_sec_open, curr_sec_high, curr_sec_low, curr_sec_close, prev_sec_open, prev_sec_high, prev_sec_low, prev_sec_close, prev_sec_time, time_close]

[sec_open, sec_high, sec_low, sec_close, prev_sec_open, prev_sec_high, prev_sec_low, prev_sec_close, prev_sec_time, sec_time] = request.security(syminfo.tickerid, resolution, calc_OHLC_for_pivot(custom_years_divisor), lookahead=barmerge.lookahead_on)
sec_open_gaps_on = request.security(syminfo.tickerid, resolution, open, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)

// Global variables for ta.change() results
time_change = ta.change(time(resolution)) != 0
sec_open_change = ta.change(sec_open) != 0

is_change_years = custom_years_divisor > 0 and time_change and year(time_close) % custom_years_divisor == 0

var is_change = false
var uses_current_bar = timeframe.isintraday and kind == WOODIE
var change_time = int(na)
is_time_change = time_change and custom_years_divisor == SIMPLE_DIVISOR or is_change_years
if is_time_change
    change_time := time

var start_time = time
var was_last_premarket = false
var start_calculate_in_premarket = false

is_last_premarket = barstate.islast and session.ispremarket and time_close > sec_time and not was_last_premarket

if is_last_premarket
    was_last_premarket := true
    start_calculate_in_premarket := true
if session.ismarket
    was_last_premarket := false

without_time_change = barstate.islast and array.size(arr_time) == 0
is_can_calc_pivot = not uses_current_bar and is_time_change and session.ismarket or sec_open_change and not start_calculate_in_premarket or is_last_premarket or uses_current_bar and not na(sec_open_gaps_on) or without_time_change
enough_bars_for_calculate = prev_sec_time >= start_time or is_daily_based

if is_can_calc_pivot and enough_bars_for_calculate
    if array.size(arr_time) == 0 and is_daily_based
        pivotX_prev_open := prev_sec_open[1]
        pivotX_prev_high := prev_sec_high[1]
        pivotX_prev_low := prev_sec_low[1]
        pivotX_prev_close := prev_sec_close[1]
        pivotX_open := sec_open[1]
        pivotX_high := sec_high[1]
        pivotX_low := sec_low[1]
        array.push(arr_time, start_time)
        calc_pivot()

    if is_daily_based
        if is_last_premarket
            pivotX_prev_open := sec_open
            pivotX_prev_high := sec_high
            pivotX_prev_low := sec_low
            pivotX_prev_close := sec_close
            pivotX_open := open
            pivotX_high := high
            pivotX_low := low
        else
            pivotX_prev_open := prev_sec_open
            pivotX_prev_high := prev_sec_high
            pivotX_prev_low := prev_sec_low
            pivotX_prev_close := prev_sec_close
            pivotX_open := sec_open
            pivotX_high := sec_high
            pivotX_low := sec_low
    else
        pivotX_prev_high := pivotX_high
        pivotX_prev_low := pivotX_low
        pivotX_prev_open := pivotX_open
        pivotX_prev_close := close[1]
        pivotX_open := open
        pivotX_high := high
        pivotX_low := low

    if barstate.islast and not is_change and array.size(arr_time) > 0 and not without_time_change
        array.set(arr_time, array.size(arr_time) - 1, change_time)
    else if without_time_change
        array.push(arr_time, start_time)
    else
        array.push(arr_time, nz(change_time, time))

    calc_pivot()

    if array.size(arr_time) > look_back
        if array.size(arr_time) > 0
            array.shift(arr_time)
        if array.size(p) > 0 and p_show and show_pivot_points
            array.shift(p)
        if array.size(r1) > 0 and r1_show and show_pivot_points
            array.shift(r1)
        if array.size(s1) > 0 and s1_show and show_pivot_points
            array.shift(s1)
        if array.size(r2) > 0 and r2_show and show_pivot_points
            array.shift(r2)
        if array.size(s2) > 0 and s2_show and show_pivot_points
            array.shift(s2)
        if array.size(r3) > 0 and r3_show and show_pivot_points
            array.shift(r3)
        if array.size(s3) > 0 and s3_show and show_pivot_points
            array.shift(s3)
        if array.size(r4) > 0 and r4_show and show_pivot_points
            array.shift(r4)
        if array.size(s4) > 0 and s4_show and show_pivot_points
            array.shift(s4)
        if array.size(r5) > 0 and r5_show and show_pivot_points
            array.shift(r5)
        if array.size(s5) > 0 and s5_show and show_pivot_points
            array.shift(s5)
    is_change := true
else if not is_daily_based
    pivotX_high := math.max(pivotX_high, high)
    pivotX_low := math.min(pivotX_low, low)

if barstate.islast and not is_daily_based and array.size(arr_time) == 0
    runtime.error('Not enough intraday data to calculate Pivot Points.')

if barstate.islast and array.size(arr_time) > 0 and is_change
    is_change := false
    if custom_years_divisor > 0
        last_pivot_time = array.get(arr_time, array.size(arr_time) - 1)
        pivot_timeframe = str.tostring(12 * custom_years_divisor) + 'M'
        estimate_pivot_time = last_pivot_time + timeframe.in_seconds(pivot_timeframe) * 1000
        array.push(arr_time, estimate_pivot_time)
    else
        array.push(arr_time, time_close(resolution))

    for i = 0 to array.size(lines) - 1 by 1
        if array.size(lines) > 0
            line.delete(array.shift(lines))
        if array.size(labels) > 0
            label.delete(array.shift(labels))

    for i = 0 to array.size(arr_time) - 2 by 1
        if array.size(p) > 0 and p_show and show_pivot_points
            draw_line(i, p, p_color)
            draw_label(i, array.get(p, i), 'P', p_color)
        if array.size(r1) > 0 and r1_show and show_pivot_points
            draw_line(i, r1, r1_color)
            draw_label(i, array.get(r1, i), 'R1', r1_color)
        if array.size(s1) > 0 and s1_show and show_pivot_points
            draw_line(i, s1, s1_color)
            draw_label(i, array.get(s1, i), 'S1', s1_color)
        if array.size(r2) > 0 and r2_show and show_pivot_points
            draw_line(i, r2, r2_color)
            draw_label(i, array.get(r2, i), 'R2', r2_color)
        if array.size(s2) > 0 and s2_show and show_pivot_points
            draw_line(i, s2, s2_color)
            draw_label(i, array.get(s2, i), 'S2', s2_color)
        if array.size(r3) > 0 and r3_show and show_pivot_points
            draw_line(i, r3, r3_color)
            draw_label(i, array.get(r3, i), 'R3', r3_color)
        if array.size(s3) > 0 and s3_show and show_pivot_points
            draw_line(i, s3, s3_color)
            draw_label(i, array.get(s3, i), 'S3', s3_color)
        if array.size(r4) > 0 and r4_show and show_pivot_points
            draw_line(i, r4, r4_color)
            draw_label(i, array.get(r4, i), 'R4', r4_color)
        if array.size(s4) > 0 and s4_show and show_pivot_points
            draw_line(i, s4, s4_color)
            draw_label(i, array.get(s4, i), 'S4', s4_color)
        if array.size(r5) > 0 and r5_show and show_pivot_points
            draw_line(i, r5, r5_color)
            draw_label(i, array.get(r5, i), 'R5', r5_color)
        if array.size(s5) > 0 and s5_show and show_pivot_points
            draw_line(i, s5, s5_color)
            draw_label(i, array.get(s5, i), 'S5', s5_color)

// Wyodrębnienie wywołań ta.cross do osobnych zmiennych
cross_pp = ta.cross(close, array.size(p) > 0 ? array.get(p, array.size(p) - 1) : na)
cross_s1 = ta.cross(close, array.size(s1) > 0 ? array.get(s1, array.size(s1) - 1) : na)
cross_s2 = ta.cross(close, array.size(s2) > 0 ? array.get(s2, array.size(s2) - 1) : na)
cross_s3 = ta.cross(close, array.size(s3) > 0 ? array.get(s3, array.size(s3) - 1) : na)
cross_s4 = ta.cross(close, array.size(s4) > 0 ? array.get(s4, array.size(s4) - 1) : na)
cross_s5 = ta.cross(close, array.size(s5) > 0 ? array.get(s5, array.size(s5) - 1) : na)
cross_r1 = ta.cross(close, array.size(r1) > 0 ? array.get(r1, array.size(r1) - 1) : na)
cross_r2 = ta.cross(close, array.size(r2) > 0 ? array.get(r2, array.size(r2) - 1) : na)
cross_r3 = ta.cross(close, array.size(r3) > 0 ? array.get(r3, array.size(r3) - 1) : na)
cross_r4 = ta.cross(close, array.size(r4) > 0 ? array.get(r4, array.size(r4) - 1) : na)
cross_r5 = ta.cross(close, array.size(r5) > 0 ? array.get(r5, array.size(r5) - 1) : na)

// Warunki alarmowe dla Pivot Points
alert_pp = array.size(p) > 0 and cross_pp
alert_s1 = array.size(s1) > 0 and cross_s1
alert_s2 = array.size(s2) > 0 and cross_s2
alert_s3 = array.size(s3) > 0 and cross_s3
alert_s4 = array.size(s4) > 0 and cross_s4
alert_s5 = array.size(s5) > 0 and cross_s5
alert_r1 = array.size(r1) > 0 and cross_r1
alert_r2 = array.size(r2) > 0 and cross_r2
alert_r3 = array.size(r3) > 0 and cross_r3
alert_r4 = array.size(r4) > 0 and cross_r4
alert_r5 = array.size(r5) > 0 and cross_r5

// HTS Wstęgi - Kijun-Sen
// Wykres linii Kijun-sen
basePeriods = input.int(26, title='Okres Kijun-Sen:', group=g7)
kijun_color = input.color(color.new(#ffff00, 60), 'Kolor Kijun-Sen:', group=g7)

donchian(len) => math.avg(ta.lowest(len), ta.highest(len))
baseLine = donchian(basePeriods)

plot(show_kijun_sen ? baseLine : na, 'Linia Kijun-Sen:', kijun_color, 1)

// HTS Wstęgi - Kijun-Sen - Drugi interwał czasowy
// Ustawienia dla drugiego Kijun-Sen
kijun2_tf = input.timeframe(title='Interwał czasowy:', defval='60', group=g7a)
kijun2_basePeriods = input.int(26, title='Okres Kijun-Sen - Drugi interwał czasowy:', group=g7a)
kijun2_color = input.color(color.new(#ffff00, 60), 'Kolor Kijun-Sen - Drugi interwał czasowy:', group=g7a)

kijun2_donchian(len) => math.avg(ta.lowest(len), ta.highest(len))
kijun2_baseLine = request.security(syminfo.tickerid, kijun2_tf, kijun2_donchian(kijun2_basePeriods), gaps=barmerge.gaps_on)

plot(show_kijun_sen2 ? kijun2_baseLine : na, 'Linia Kijun-Sen - Drugi interwał:', kijun2_color, 1)

// HTS Wstęgi - VWAP - Volume Weighted Average Price
// ustawienia VWAP
vwap_tf = input.timeframe(title="Interwał czasowy VWAP:", defval="", group=g8)
hideonDWM = input.bool(false, title="Ukryj VWAP na interwałach D/W/M", group=g8)
anchor = input.string("Session", title="Okres bazowy:", options=["Session", "Week", "Month", "Quarter", "Year", "Decade", "Century", "Earnings", "Dividends", "Splits"], group=g8)
src_vwap = input(hlc3, title="Źródło VWAP:", group=g8)
offset_vwap = input.int(0, title="Odsadzenie VWAP:", minval=0, group=g8)
vwap_color = input.color(#2962FF, title="Kolor VWAP:", group=g8)
vwap_linewidth = input.int(1, title="Grubość linii VWAP:", minval=1, maxval=5, group=g8)

// Obliczanie VWAP dla wybranego interwału czasowego
var float vwapValue = na
if show_vwap and not (hideonDWM and timeframe.isdwm)
    isNewPeriod = switch anchor
        "Earnings"  => not na(request.earnings(syminfo.tickerid))
        "Dividends" => not na(request.dividends(syminfo.tickerid))
        "Splits"    => not na(request.splits(syminfo.tickerid, field="ratio"))  // Dodano field="ratio"
        "Session"   => timeframe.change("D")
        "Week"      => timeframe.change("W")
        "Month"     => timeframe.change("M")
        "Quarter"   => timeframe.change("3M")
        "Year"      => timeframe.change("12M")
        "Decade"    => timeframe.change("12M") and year % 10 == 0
        "Century"   => timeframe.change("12M") and year % 100 == 0
        => false

    // Pobieranie danych VWAP z wybranego interwału czasowego
    [_vwap, _, _] = request.security(syminfo.tickerid, vwap_tf, ta.vwap(src_vwap, isNewPeriod, 1), gaps=barmerge.gaps_on)
    vwapValue := _vwap

// Rysowanie VWAP na wykresie
plot(show_vwap ? vwapValue : na, title="VWAP", color=vwap_color, offset=offset_vwap, linewidth=vwap_linewidth)

// HTS Wstęgi - PO3 - Power of Three
// Ustawienia dla PO3
var tf = input.timeframe("60", "Interwał:", inline="tf", group=g9)
var tf_auto = input.bool(false, "Ustal automatycznie", inline="tf", group=g9)
var tf_2lvs = input.bool(false, "Dwu poziomowy", inline="tf", group=g9)
var num = input.int(1, "Liczba HTF świeczek:", minval=1, group=g9)
var offset = input.int(10, "Odsadzenie:", group=g9)
var size = input.string("Medium", "Wielkość:", options=["Small", "Medium", "Large"], group=g9)
var type = input.string("Candles", "Typ:", options=["Candles", "Heikin Ashi"], group=g9)
var margin = input.int(1, "Odstep między:", minval=1, group=g9)
var htf_data = input.string("Is Weekly", "Użyj HTF danych do wygenerowania świeczki:", options=["Is Weekly", "Always", "Never"], group=g9)

// Inputs for Candle Colors
var up_col = input.color(color.new(#089981, 0), "Body", inline="Candles", group=g9a)
var up_col_wick = input.color(color.new(#089981, 0), "Wick", inline="Candles", group=g9a)
var up_col_border = input.color(color.new(#089981, 0), "Border", inline="Candles", group=g9a)
var down_col = input.color(color.new(#f23645, 0), "Body", inline="Candles", group=g9b)
var down_col_wick = input.color(color.new(#f23645, 0), "Wick", inline="Candles", group=g9b)
var down_col_border = input.color(color.new(#f23645, 0), "Border", inline="Candles", group=g9b)

// Inputs for Projections
var o_col = input.color(color.new(#b2b5be, 10), "", inline="o", group=g9c)
var o_style = input.string("Dotted", "", options=["Solid", "Dotted", "Dashed"], inline="o", group=g9c)
var o_width = input.int(1, "Grubość lini:", minval=1, inline="o", group=g9c)
var o_enabled = input.bool(true, "Open", inline="o", group=g9c)
var hl_col = input.color(color.new(#b2b5be, 10), "", inline="hl", group=g9c)
var hl_style = input.string("Dotted", "", options=["Solid", "Dotted", "Dashed"], inline="hl", group=g9c)
var hl_width = input.int(1, "Grubość lini:", minval=1, inline="hl", group=g9c)
var hl_enabled = input.bool(true, "High/Low", inline="hl", group=g9c)
var ohlc_col = input.color(color.new(#b2b5be, 10), "", inline="ohlc", group=g9c)
var ohlc_size = input.string("Auto", "", options=["Auto", "Tiny", "Small", "Normal", "Large", "Huge"], inline="ohlc", group=g9c)
var ohlc_enabled = input.bool(true, "OHLC Prices", inline="ohlc", group=g9c)

// New Inputs for Label Font Size and Color
var font_size = input.string("Small", "Wielkośc czcionki:", options=["Tiny", "Small", "Normal", "Large", "Huge"], group=g9c)
var font_color = input.color(#b2b5be, "Kolor czcionki:", group=g9c)

// Candle Structure
type Candle
    box body
    line upperWick
    line lowerWick
    line o
    line h
    line l
    label labelO
    label labelH
    label labelL
    label labelC

// Helper Functions
getAutoTimeframe(s, m5, m15, m60, m240, m, d, w, q, y) =>
    timeframe.isseconds ? s :
     timeframe.isminutes ? 
      timeframe.multiplier < 5 ? m5 : 
      timeframe.multiplier < 15 ? m15 : 
      timeframe.multiplier < 60 ? m60 :
      timeframe.multiplier < 240 ? m240 : m :
     timeframe.isdaily ? d :
     timeframe.isweekly ? w :
     timeframe.ismonthly and timeframe.multiplier < 6 ? q : y

determineAutoTimeframe() =>
    if tf_2lvs
        getAutoTimeframe('5', '15', '60', '240', '1D', '1W', '1M', '3M', '12M', '12M')
    else
        getAutoTimeframe('1', '5', '15', '60', '240', '1D', '1W', '1M', '3M', '12M')

getSizeMultiplier() =>
    result = switch size
        "Small" => 1
        "Medium" => 2
        "Large" => 3
    result

getLineStyle(style) =>
    result = switch style
        "Solid" => line.style_solid
        "Dotted" => line.style_dotted
        "Dashed" => line.style_dashed
    result

getLabelSize() =>
    result = switch font_size
        "Tiny" => size.tiny
        "Small" => size.small
        "Normal" => size.normal
        "Large" => size.large
        "Huge" => size.huge
    result

// Main Logic
var maxIndex = num - 1
var curr_tf = tf_auto ? determineAutoTimeframe() : tf
var useHtfData = (timeframe.isweekly and htf_data == "Is Weekly") or htf_data == "Always"
var sizeMultiplier = getSizeMultiplier()
newCandle = ta.change(time(curr_tf)) != 0

ohlc() =>
    [htf_o, htf_h, htf_l, htf_c] = request.security(syminfo.tickerid, curr_tf, [open, high, low, close], lookahead=barmerge.lookahead_on)
    var o = 0.
    var h = 0.
    var l = 0.
    c = close

    if newCandle
        o := open
        h := high
        l := low
    else
        h := math.max(high, h)
        l := math.min(low, l)
    
    [o, h, l, c, htf_o, htf_h, htf_l, htf_c]

getCandlePostion(l_pos) =>
    m_pos = l_pos + sizeMultiplier
    r_pos = l_pos + (sizeMultiplier * 2)
    [m_pos, r_pos]

createLabel(r_pos, s) =>
    label.new(r_pos, s, str.tostring(s, format.mintick), style=label.style_label_left, color=color.new(color.black, 100), textcolor=font_color, size=getLabelSize())

createLabels(Candle candle, o, h, l, c, l_pos) =>
    if show_po3 and ohlc_enabled    
        [m_pos, r_pos] = getCandlePostion(l_pos)
        if o_enabled
            candle.labelO := createLabel(r_pos, o)
            candle.labelC := createLabel(r_pos, c)
        if hl_enabled
            candle.labelH := createLabel(r_pos, h)
            candle.labelL := createLabel(r_pos, l)

moveLabel(label la, r_pos, s) =>
    la.set_text(str.tostring(s, format.mintick))
    la.set_xy(r_pos, s)

moveLabels(Candle candle, l_pos, o, h, l, c) =>
    if show_po3
        [m_pos, r_pos] = getCandlePostion(l_pos)
        if o_enabled
            moveLabel(candle.labelO, r_pos, o)
            moveLabel(candle.labelC, r_pos, c)
        if hl_enabled
            moveLabel(candle.labelH, r_pos, h)
            moveLabel(candle.labelL, r_pos, l)

deleteLabels(Candle candle) =>
    if show_po3
        if o_enabled
            candle.labelO.delete()
            candle.labelC.delete()
        if hl_enabled
            candle.labelH.delete()
            candle.labelL.delete()

createProjections(Candle candle, o, h, l, curr_o, curr_h, curr_l, htf_o, htf_h, htf_l, l_pos) =>
    [m_pos, r_pos] = getCandlePostion(l_pos)
    b_o = bar_index
    b_h = bar_index
    b_l = bar_index
    o_o = o
    o_h = h
    o_l = l
    if useHtfData
        if htf_o != o
            b_o := b_o - 1
            o_o := curr_o
        if htf_h != h
            b_h := b_h - 1
            o_h := curr_h
        if htf_l != l
            b_l := b_l - 1
            o_l := curr_l

    if show_po3 and o_enabled  // Dodaj warunek show_po3
        candle.o := line.new(b_o, o_o, m_pos, o_o, style=getLineStyle(o_style), color=o_col, width=o_width)
    if show_po3 and hl_enabled  // Dodaj warunek show_po3
        candle.h := line.new(b_h, o_h, m_pos, o_h, style=getLineStyle(hl_style), color=hl_col, width=hl_width)
        candle.l := line.new(b_l, o_l, m_pos, o_l, style=getLineStyle(hl_style), color=hl_col, width=hl_width)

moveProjections(Candle candle, l_pos, o, h, l, curr_o, curr_h, curr_l) =>
    [m_pos, r_pos] = getCandlePostion(l_pos)
    if show_po3 and o_enabled  // Dodaj warunek show_po3
        candle.o.set_y1(curr_o)
        candle.o.set_xy2(m_pos, curr_o)
    if show_po3 and hl_enabled  // Dodaj warunek show_po3
        old_h = candle.h.get_y1()
        old_l = candle.l.get_y1()

        if h > old_h or (useHtfData and h[1] < old_h)
            candle.h.set_x1(bar_index)
        candle.h.set_y1(curr_h)
        candle.h.set_xy2(m_pos, curr_h)

        if l < old_l or (useHtfData and l[1] > old_l)
            candle.l.set_x1(bar_index)
        candle.l.set_y1(curr_l)
        candle.l.set_xy2(m_pos, curr_l)

deleteProjections(Candle candle) =>
    if show_po3 and o_enabled  // Dodaj warunek show_po3
        candle.o.delete()
    if show_po3 and hl_enabled  // Dodaj warunek show_po3
        candle.h.delete()
        candle.l.delete()

getCandleProperties(o, h, l, c) =>
    h_body = math.max(o, c)
    l_body = math.min(o, c)
    body_col = o > c ? down_col : up_col
    wick_col = o > c ? down_col_wick : up_col_wick
    border_col = o > c ? down_col_border : up_col_border
    [h_body, l_body, body_col, wick_col, border_col]

createCandle(l_pos, o, h, l, c) =>
    [m_pos, r_pos] = getCandlePostion(l_pos)
    [h_body, l_body, body_col, wick_col, border_col] = getCandleProperties(o, h, l, c)
    candle = Candle.new()
    if show_po3
        candle.body := box.new(l_pos, h_body, r_pos, l_body, border_col, bgcolor=body_col)
        candle.upperWick := line.new(m_pos, h_body, m_pos, h, color=wick_col)
        candle.lowerWick := line.new(m_pos, l_body, m_pos, l, color=wick_col)
    candle

moveCandle(Candle candle, l_pos) =>
    [m_pos, r_pos] = getCandlePostion(l_pos)
    candle.body.set_left(l_pos)
    candle.body.set_right(r_pos)
    candle.upperWick.set_x1(m_pos)
    candle.upperWick.set_x2(m_pos)
    candle.lowerWick.set_x1(m_pos)
    candle.lowerWick.set_x2(m_pos)

updateCandle(Candle candle, l_pos, o, h, l, c) =>
    [m_pos, r_pos] = getCandlePostion(l_pos)
    [h_body, l_body, body_col, wick_col, border_col] = getCandleProperties(o, h, l, c)
    if show_po3
        candle.body.set_bgcolor(body_col)
        candle.body.set_lefttop(l_pos, h_body)
        candle.body.set_rightbottom(r_pos, l_body)
        candle.body.set_border_color(border_col)
        candle.upperWick.set_color(wick_col)
        candle.upperWick.set_xy1(m_pos, h_body)
        candle.upperWick.set_xy2(m_pos, h)
        candle.lowerWick.set_color(wick_col)
        candle.lowerWick.set_xy1(m_pos, l_body)
        candle.lowerWick.set_xy2(m_pos, l)
    if show_po3 and ohlc_enabled
        moveLabel(candle.labelC, r_pos, c)

deleteCandle(Candle candle) =>
    if show_po3
        candle.body.delete()
        candle.upperWick.delete()
        candle.lowerWick.delete()
        deleteLabels(candle)
    deleteProjections(candle)

var candles = array.new<Candle>(num, Candle.new())
[o, h, l, c, htf_o, htf_h, htf_l, htf_c] = ohlc()
curr_o = o
curr_h = h
curr_l = l
curr_c = c

if useHtfData
    curr_o := htf_o
    curr_h := htf_h
    curr_l := htf_l
    curr_c := htf_c

candle_o = curr_o
candle_h = curr_h
candle_l = curr_l
candle_c = curr_c

if type == "Heikin Ashi" and not chart.is_heikinashi
    candle_c := (curr_o + curr_h + curr_l + curr_c) / 4
    if newCandle
        candle_o := na(candle_o[1]) ? (curr_o + curr_c) / 2 : (nz(candle_o[1]) + nz(candle_c[1])) / 2
    else
        candle_o := nz(candle_o[1])
    candle_h := math.max(curr_h, candle_o, candle_c) 
    candle_l := math.min(curr_l, candle_o, candle_c)        

if newCandle
    oldCandle = candles.shift()
    deleteCandle(oldCandle)
    pos = bar_index + offset + maxIndex * (3 + sizeMultiplier)
    candle = createCandle(pos, candle_o, candle_h, candle_l, candle_c)
    createProjections(candle, o, h, l, curr_o, curr_h, curr_l, htf_o, htf_h, htf_l, pos)
    createLabels(candle, curr_o, curr_h, curr_l, curr_c, pos)
    candles.push(candle)

for [i, candle] in candles
    new_pos = bar_index + offset + i * (margin + (2 * sizeMultiplier))
    if i < maxIndex
        moveCandle(candle, new_pos)
        deleteProjections(candle) 
        deleteLabels(candle)
    else
        updateCandle(candle, new_pos, candle_o, candle_h, candle_l, candle_c)
        moveProjections(candle, new_pos, o, h, l, curr_o, curr_h, curr_l)
        moveLabels(candle, new_pos, curr_o, curr_h, curr_l, curr_c)

// HTS Wstęgi - Tabele trendów
// Pozycja tabeli
tableLocation = input.string('Prawy dolny róg', title='Położenie tabeli z Trendem:', options=['Lewy górny róg', 'Lewa strona środek', 'Lewy dolny róg', 'Środek góra', 'Środek', 'Środek dół', 'Prawy górny róg', 'Prawa strona środek', 'Prawy dolny róg'], group=g10)
neutralSymbol = input.string("●", title="Symbol neutralny:", options=["●", "⏺", "▪", "■", "🐈", "🐱", "😸", "😹", "😺", "😻", "😼", "😽", "😾", "😿", "🙀"], group=g10)
rsiLength = input.int(14, title='Długość RSI:', group=g10)

// Deklaracja zmiennej tabeli
var table trendTable = na

// Zmienna globalna dla pozycji tabeli
var tablePos = position.top_right
switch tableLocation
    'Lewy górny róg' => tablePos := position.top_left
    'Lewa strona środek' => tablePos := position.middle_left
    'Lewy dolny róg' => tablePos := position.bottom_left
    'Środek góra' => tablePos := position.top_center
    'Środek' => tablePos := position.middle_center
    'Środek dół' => tablePos := position.bottom_center
    'Prawy górny róg' => tablePos := position.top_right
    'Prawa strona środek' => tablePos := position.middle_right
    'Prawy dolny róg' => tablePos := position.bottom_right

// Aktualizacja tabeli w nowej pozycji
if barstate.isfirst and show_trend_table
    if na(trendTable)
        trendTable := table.new(tablePos, 5, 5, border_width=3)
    else
        table.delete(trendTable)
        trendTable := table.new(tablePos, 5, 5, border_width=3)

// Kolory dla trendów
upColor = #089981
downColor = #f23645
neutralColor = #fbff00

// Warunki trendu
isUptrendAlert = ta.crossover(HTSFastLow, HTSSlowHigh)
isDowntrendAlert = ta.crossunder(HTSFastHigh, HTSSlowLow)

// Funkcja pobierająca trend z różnych interwałów
f_getTrend() =>
    HTSFastHigh_local = ta.rma(high, lenFast)
    HTSFastLow_local = ta.rma(low, lenFast)
    HTSSlowHigh_local = ta.rma(high, lenSlow)
    HTSSlowLow_local = ta.rma(low, lenSlow)
    isUptrend_local = HTSFastLow_local > HTSSlowHigh_local
    isDowntrend_local = HTSFastHigh_local < HTSSlowLow_local
    [isUptrend_local, isDowntrend_local]

// Funkcja wypełniająca komórki tabeli
f_fillCell(_column, _row, _cellText, _c_color, _text_color) =>
    table.cell(trendTable, _column, _row, _cellText, bgcolor=color.new(_c_color, 90), text_color=_text_color, height=3, width=4)

// Funkcje sprawdzające pozycję ceny względem wstęg dla różnych interwałów
f_getPriceBandPosition() =>
    priceAboveFast = close > HTSFastHigh
    priceInsideFast = close < HTSFastHigh and close > HTSFastLow
    priceBelowFast = close < HTSFastLow

    priceAboveSlow = close > HTSSlowHigh
    priceInsideSlow = close < HTSSlowHigh and close > HTSSlowLow
    priceBelowSlow = close < HTSSlowLow

    [priceAboveFast, priceInsideFast, priceBelowFast, priceAboveSlow, priceInsideSlow, priceBelowSlow]

// Funkcja określająca kolor komórki RSI
f_rsiColor(rsi) =>
    rsi > 70 ? downColor : rsi < 30 ? #00e676 : upColor

// Funkcja do konwersji interwału na przyjazną nazwę
f_intervalToLabel(interval) =>
    if interval == '1'
        'm1'
    else if interval == '3'
        'm3'
    else if interval == '5'
        'm5'
    else if interval == '15'
        'm15'
    else if interval == '30'
        'm30'
    else if interval == '45'
        'm45'
    else if interval == '60'
        'H1'
    else if interval == '120'
        'H2'
    else if interval == '180'
        'H3'
    else if interval == '240'
        'H4'
    else if interval == 'D'
        'D1'
    else if interval == 'W'
        'W1'
    else if interval == 'M'
        'M1'
    else
        interval  // Domyślnie zwróć wartość wejściową, jeśli nie pasuje do żadnego przypadku

// Dodaj nowe zmienne wejściowe dla interwałów
firstInterval = input.timeframe('1', title="Pierwszy interwał dla Trendu:", group=g10a)
secondInterval = input.timeframe('5', title="Drugi interwał dla Trendu:", group=g10a)
thirdInterval = input.timeframe('60', title="Trzeci interwał dla Trendu:", group=g10a)
fourthInterval = input.timeframe('D', title="Czwarty interwał dla Trendu:", group=g10a)

// Pobieranie trendów z różnych interwałów czasowych (używając wybranych interwałów)
[up_01, down_01] = request.security(syminfo.tickerid, firstInterval, f_getTrend())
[up_02, down_02] = request.security(syminfo.tickerid, secondInterval, f_getTrend())
[up_03, down_03] = request.security(syminfo.tickerid, thirdInterval, f_getTrend())
[up_04, down_04] = request.security(syminfo.tickerid, fourthInterval, f_getTrend())

// Generowanie symboli strzałów dla różnych interwałów
glyph1 = up_01 ? '▲ ' : down_01 ? '▼ ' : neutralSymbol + ' '
glyph2 = up_02 ? '▲ ' : down_02 ? '▼ ' : neutralSymbol + ' '
glyph3 = up_03 ? '▲ ' : down_03 ? '▼ ' : neutralSymbol + ' '
glyph4 = up_04 ? '▲ ' : down_04 ? '▼ ' : neutralSymbol + ' '

// Pobieranie pozycji ceny dla różnych interwałów
[aboveF_01, insideF_01, belowF_01, aboveS_01, insideS_01, belowS_01] = request.security(syminfo.tickerid, firstInterval, f_getPriceBandPosition())
[aboveF_02, insideF_02, belowF_02, aboveS_02, insideS_02, belowS_02] = request.security(syminfo.tickerid, secondInterval, f_getPriceBandPosition())
[aboveF_03, insideF_03, belowF_03, aboveS_03, insideS_03, belowS_03] = request.security(syminfo.tickerid, thirdInterval, f_getPriceBandPosition())
[aboveF_04, insideF_04, belowF_04, aboveS_04, insideS_04, belowS_04] = request.security(syminfo.tickerid, fourthInterval, f_getPriceBandPosition())

// Pobieranie wartości RSI dla różnych interwałów
rsi_01 = request.security(syminfo.tickerid, firstInterval, ta.rsi(close, rsiLength))
rsi_02 = request.security(syminfo.tickerid, secondInterval, ta.rsi(close, rsiLength))
rsi_03 = request.security(syminfo.tickerid, thirdInterval, ta.rsi(close, rsiLength))
rsi_04 = request.security(syminfo.tickerid, fourthInterval, ta.rsi(close, rsiLength))

// W sekcji if barstate.islast dodaj po pierwszym wierszu:
if barstate.islast and show_trend_table
    // Pierwszy wiersz - trend (pozostaw bez zmian)
    f_fillCell(1, 0, glyph1 + f_intervalToLabel(firstInterval), up_01 ? upColor : down_01 ? downColor : neutralColor, up_01 ? upColor : down_01 ? downColor : neutralColor)
    f_fillCell(2, 0, glyph2 + f_intervalToLabel(secondInterval), up_02 ? upColor : down_02 ? downColor : neutralColor, up_02 ? upColor : down_02 ? downColor : neutralColor)
    f_fillCell(3, 0, glyph3 + f_intervalToLabel(thirdInterval), up_03 ? upColor : down_03 ? downColor : neutralColor, up_03 ? upColor : down_03 ? downColor : neutralColor)
    f_fillCell(4, 0, glyph4 + f_intervalToLabel(fourthInterval), up_04 ? upColor : down_04 ? downColor : neutralColor, up_04 ? upColor : down_04 ? downColor : neutralColor)

    // Drugi wiersz - pozycja względem szybkiej wstęgi
    f_fillCell(1, 1, aboveF_01 ? '▲' : insideF_01 ? neutralSymbol : '▼', aboveF_01 ? upColor : insideF_01 ? neutralColor : downColor, aboveF_01 ? upColor : insideF_01 ? neutralColor : downColor)
    f_fillCell(2, 1, aboveF_02 ? '▲' : insideF_02 ? neutralSymbol : '▼', aboveF_02 ? upColor : insideF_02 ? neutralColor : downColor, aboveF_02 ? upColor : insideF_02 ? neutralColor : downColor)
    f_fillCell(3, 1, aboveF_03 ? '▲' : insideF_03 ? neutralSymbol : '▼', aboveF_03 ? upColor : insideF_03 ? neutralColor : downColor, aboveF_03 ? upColor : insideF_03 ? neutralColor : downColor)
    f_fillCell(4, 1, aboveF_04 ? '▲' : insideF_04 ? neutralSymbol : '▼', aboveF_04 ? upColor : insideF_04 ? neutralColor : downColor, aboveF_04 ? upColor : insideF_04 ? neutralColor : downColor)

    // Trzeci wiersz - pozycja względem wolnej wstęgi
    f_fillCell(1, 2, aboveS_01 ? '▲' : insideS_01 ? neutralSymbol : '▼', aboveS_01 ? upColor : insideS_01 ? neutralColor : downColor, aboveS_01 ? upColor : insideS_01 ? neutralColor : downColor)
    f_fillCell(2, 2, aboveS_02 ? '▲' : insideS_02 ? neutralSymbol : '▼', aboveS_02 ? upColor : insideS_02 ? neutralColor : downColor, aboveS_02 ? upColor : insideS_02 ? neutralColor : downColor)
    f_fillCell(3, 2, aboveS_03 ? '▲' : insideS_03 ? neutralSymbol : '▼', aboveS_03 ? upColor : insideS_03 ? neutralColor : downColor, aboveS_03 ? upColor : insideS_03 ? neutralColor : downColor)
    f_fillCell(4, 2, aboveS_04 ? '▲' : insideS_04 ? neutralSymbol : '▼', aboveS_04 ? upColor : insideS_04 ? neutralColor : downColor, aboveS_04 ? upColor : insideS_04 ? neutralColor : downColor)

    // HTS Wstęgi - RSI w Tabeli trendów
    // Czwarty wiersz - wartości RSI (tylko jeśli show_rsi_row jest włączone)
    if show_rsi_row
        f_fillCell(1, 3, str.tostring(rsi_01, '#.0'), f_rsiColor(rsi_01), f_rsiColor(rsi_01))
        f_fillCell(2, 3, str.tostring(rsi_02, '#.0'), f_rsiColor(rsi_02), f_rsiColor(rsi_02))
        f_fillCell(3, 3, str.tostring(rsi_03, '#.0'), f_rsiColor(rsi_03), f_rsiColor(rsi_03))
        f_fillCell(4, 3, str.tostring(rsi_04, '#.0'), f_rsiColor(rsi_04), f_rsiColor(rsi_04))

    // Dodanie piątej kolumny z etykietami  
    f_fillCell(0, 0, 'Trend:', #808080, #808080)
    f_fillCell(0, 1, str.tostring(lenFast), #808080, HTSFastColor)
    f_fillCell(0, 2, str.tostring(lenSlow), #808080, HTSSlowColor)
    if show_rsi_row
        f_fillCell(0, 3, 'RSI:', #808080, #808080)

// HTS Wstęgi - Alarmy
alertcondition(isUptrendAlert, title='Trend wzrostowy - przecięcie wstęg', message='Trend wzrostowy! - Szybsza przecina wolniejszą w kierunku wzrostowym')
alertcondition(isDowntrendAlert, title='Trend spadkowy - przecięcie wstęg', message='Trend spadkowy! - Szybsza przecina wolniejszą w kierunku spadkowym')
alertcondition(ta.cross(close, vwapValue), title="Przecięcie ceny - VWAP", message="Cena przekroczyła linię VWAP")
alertcondition(alert_pp, title="Przecięcie ceny - PP", message="Cena przekroczyła poziom PP")
alertcondition(alert_s1, title="Przecięcie ceny - S1", message="Cena przekroczyła poziom S1")
alertcondition(alert_s2, title="Przecięcie ceny - S2", message="Cena przekroczyła poziom S2")
alertcondition(alert_s3, title="Przecięcie ceny - S3", message="Cena przekroczyła poziom S3")
alertcondition(alert_s4, title="Przecięcie ceny - S4", message="Cena przekroczyła poziom S4")
alertcondition(alert_s5, title="Przecięcie ceny - S5", message="Cena przekroczyła poziom S5")
alertcondition(alert_r1, title="Przecięcie ceny - R1", message="Cena przekroczyła poziom R1")
alertcondition(alert_r2, title="Przecięcie ceny - R2", message="Cena przekroczyła poziom R2")
alertcondition(alert_r3, title="Przecięcie ceny - R3", message="Cena przekroczyła poziom R3")
alertcondition(alert_r4, title="Przecięcie ceny - R4", message="Cena przekroczyła poziom R4")
alertcondition(alert_r5, title="Przecięcie ceny - R5", message="Cena przekroczyła poziom R5")
